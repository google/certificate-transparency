<?xml version="1.0" encoding="US-ASCII"?>

<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc sortrefs="yes" ?>

<rfc ipr="trust200902" category="std" submissionType="IETF" docName="draft-ietf-trans-rfc6962-bis-03">

  <front>
    <title>Certificate Transparency</title>
    <author initials="B" surname="Laurie" fullname="Ben Laurie">
      <organization abbrev="Google">
        Google UK Ltd.
      </organization>
      <address>
        <email>benl@google.com</email>
      </address>
    </author>
    <author initials="A" surname="Langley" fullname="Adam Langley">
      <organization abbrev="Google">
        Google Inc.
      </organization>
      <address>
        <email>agl@google.com</email>
      </address>
    </author>
    <author initials="E" surname="Kasper" fullname="Emilia Kasper">
      <organization abbrev="Google">
        Google Switzerland GmbH
      </organization>
      <address>
        <email>ekasper@google.com</email>
      </address>
    </author>
    <author initials="R" surname="Stradling" fullname="Rob Stradling">
      <organization abbrev="Comodo">
        Comodo CA, Ltd.
      </organization>
      <address>
        <email>rob.stradling@comodo.com</email>
      </address>
    </author>
    <date />
    <workgroup>Public Notary Transparency Working Group</workgroup>

    <abstract>
      <t>
        This document describes an experimental protocol for publicly logging
the existence of Transport Layer Security (TLS) certificates as they are issued
or observed, in a manner that allows anyone to audit certificate authority (CA)
activity and notice the issuance of suspect certificates as well as to audit
the certificate logs themselves. The intent is that eventually clients would
refuse to honor certificates that do not appear in a log, effectively forcing
CAs to add all issued certificates to the logs.
      </t>
      <t>
        Logs are network services that implement the protocol operations for
submissions and queries that are defined in this document.
      </t>
    </abstract>
  </front>
  <middle>
    <section title="Informal Introduction">
      <t>
        Certificate transparency aims to mitigate the problem of misissued
certificates by providing publicly auditable, append-only, untrusted logs of
all issued certificates. The logs are publicly auditable so that it is possible
for anyone to verify the correctness of each log and to monitor when new
certificates are added to it. The logs do not themselves prevent misissue, but
they ensure that interested parties (particularly those named in certificates)
can detect such misissuance. Note that this is a general mechanism, but in this
document, we only describe its use for public TLS server certificates issued by
public certificate authorities (CAs).
      </t>
      <t>
        Each log consists of certificate chains, which can be submitted by
anyone. It is expected that public CAs will contribute all their newly issued
certificates to one or more logs; it is also expected that certificate holders
will contribute their own certificate chains. In order to avoid logs being
spammed into uselessness, it is required that each chain is rooted in a known
CA certificate. When a chain is submitted to a log, a signed timestamp is
returned, which can later be used to provide evidence to clients that the chain
has been submitted. TLS clients can thus require that all certificates they see
have been logged.
      </t>
      <t>
        Those who are concerned about misissue can monitor the logs, asking
them regularly for all new entries, and can thus check whether domains they are
responsible for have had certificates issued that they did not expect. What
they do with this information, particularly when they find that a misissuance
has happened, is beyond the scope of this document, but broadly speaking, they
can invoke existing business mechanisms for dealing with misissued
certificates. Of course, anyone who wants can monitor the logs and, if they
believe a certificate is incorrectly issued, take action as they see fit.
      </t>
      <t>
        Similarly, those who have seen signed timestamps from a particular log can later demand a proof of inclusion from that log. If the log is unable to provide this (or, indeed, if the corresponding certificate is absent from monitors' copies of that log), that is evidence of the incorrect operation of the log. The checking operation is asynchronous to allow TLS connections to proceed without delay, despite network connectivity issues and the vagaries of firewalls.
      </t>
      <t>
        The append-only property of each log is technically achieved using Merkle Trees, which can be used to show that any particular version of the log is a superset of any particular previous version. Likewise, Merkle Trees avoid the need to blindly trust logs: if a log attempts to show different things to different people, this can be efficiently detected by comparing tree roots and consistency proofs. Similarly, other misbehaviors of any log (e.g., issuing signed timestamps for certificates they then don't log) can be efficiently detected and proved to the world at large.
      </t>
      <section title="Requirements Language">
        <t>
          The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
        </t>
      </section>
      <section title="Data Structures">
        <t>
          Data structures are defined according to the conventions laid out in
Section 4 of <xref target="RFC5246"/>.
        </t>
      </section>
    </section>
    <section title="Cryptographic Components">
      <section title="Merkle Hash Trees">
        <t>
          Logs use a binary Merkle Hash Tree for efficient auditing. The
hashing algorithm is <xref target="FIPS.180-4">SHA-256</xref> (note that
this is fixed for this experiment, but it is anticipated that each log would be
able to specify a hash algorithm). The input to the Merkle Tree Hash is a list
of data entries; these entries will be hashed to form the leaves of the Merkle
Hash Tree. The output is a single 32-byte Merkle Tree Hash. Given an ordered
list of n inputs, D[n] = {d(0), d(1), ..., d(n-1)}, the Merkle Tree Hash (MTH)
is thus defined as follows:
        </t>
        <t>
          The hash of an empty list is the hash of an empty string:
          <vspace blankLines='1' />
          MTH({}) = SHA-256().
          <vspace blankLines='1' />
          The hash of a list with one entry (also known as a leaf hash) is:
          <vspace blankLines='1' />
          MTH({d(0)}) = SHA-256(0x00 || d(0)).
          <vspace blankLines='1' />
          For n &gt; 1, let k be the largest power of two smaller than n (i.e., k &lt; n &lt;= 2k). The Merkle Tree Hash of an n-element list D[n] is then defined recursively as
          <vspace blankLines='1' />
          MTH(D[n]) = SHA-256(0x01 || MTH(D[0:k]) || MTH(D[k:n])),
          <vspace blankLines='1' />
          where || is concatenation and D[k1:k2] denotes the list {d(k1), d(k1+1),..., d(k2-1)} of length (k2 - k1). (Note that the hash calculations for leaves and nodes differ. This domain separation is required to give second preimage resistance.)
        </t>
        <t>
          Note that we do not require the length of the input list to be a
power of two. The resulting Merkle Tree may thus not be balanced; however, its
shape is uniquely determined by the number of leaves. (Note: This Merkle Tree is
essentially the same as the <xref target='CrosbyWallach'>history tree</xref>
proposal, except our definition handles non-full trees differently.)
        </t>
      <section title="Merkle Audit Paths" anchor='merkle_paths'>
        <t>
          A Merkle audit path for a leaf in a Merkle Hash Tree is the shortest
list of additional nodes in the Merkle Tree required to compute the Merkle Tree
Hash for that tree. Each node in the tree is either a leaf node or is computed
from the two nodes immediately below it (i.e., towards the leaves). At each
step up the tree (towards the root), a node from the audit path is combined
with the node computed so far. In other words, the audit path consists of the
list of missing nodes required to compute the nodes leading from a leaf to the
root of the tree. If the root computed from the audit path matches the true
root, then the audit path is proof that the leaf exists in the tree.
        </t>
        <t> Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle audit path PATH(m, D[n]) for the (m+1)th input d(m), 0 &lt;= m &lt; n, is defined as follows:
        </t>
        <t>
          The path for the single leaf in a tree with a one-element input list D[1] = {d(0)} is empty:
          <vspace blankLines='1' />
          PATH(0, {d(0)}) = {}
          <vspace blankLines='1' />
          For n &gt; 1, let k be the largest power of two smaller than n. The path for the (m+1)th element d(m) in a list of n &gt; m elements is then defined recursively as
          <vspace blankLines='1' />
          PATH(m, D[n]) = PATH(m, D[0:k]) : MTH(D[k:n]) for m &lt; k; and
          <vspace blankLines='1' />
          PATH(m, D[n]) = PATH(m - k, D[k:n]) : MTH(D[0:k]) for m &gt;= k,
          <vspace blankLines='1' />
          where : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
        </t>
      </section>

      <section title="Merkle Consistency Proofs" anchor='consistency'>
        <t>
          Merkle consistency proofs prove the append-only property of the tree. A Merkle consistency proof for a Merkle Tree Hash MTH(D[n]) and a previously advertised hash MTH(D[0:m]) of the first m leaves, m &lt;= n, is the list of nodes in the Merkle Tree required to verify that the first m inputs D[0:m] are equal in both trees. Thus, a consistency proof must contain a set of intermediate nodes (i.e., commitments to inputs) sufficient to verify MTH(D[n]), such that (a subset of) the same nodes can be used to verify MTH(D[0:m]). We define an algorithm that outputs the (unique) minimal consistency proof. 
        </t>
        <t>
          Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle consistency proof PROOF(m, D[n]) for a previous Merkle Tree Hash MTH(D[0:m]), 0 &lt; m &lt; n, is defined as:
          <vspace blankLines='1' />
          PROOF(m, D[n]) = SUBPROOF(m, D[n], true)
          <vspace blankLines='1' />
          The subproof for m = n is empty if m is the value for which PROOF was originally requested (meaning that the subtree Merkle Tree Hash MTH(D[0:m]) is known):
          <vspace blankLines='1' />
          SUBPROOF(m, D[m], true) = {}
          <vspace blankLines='1' />
           The subproof for m = n is the Merkle Tree Hash committing inputs D[0:m]; otherwise:
          <vspace blankLines='1' />
          SUBPROOF(m, D[m], false) = {MTH(D[m])}
          <vspace blankLines='1' />    
          For m &lt; n, let k be the largest power of two smaller than n. The subproof is then defined recursively.
          <vspace blankLines='1' />
If m &lt;= k, the right subtree entries D[k:n] only exist in the current tree. We prove that the left subtree entries D[0:k] are consistent and add a commitment to D[k:n]:
          <vspace blankLines='1' />
          SUBPROOF(m, D[n], b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n])
          <vspace blankLines='1' />
If m > k, the left subtree entries D[0:k] are identical in both trees. We prove that the right subtree entries D[k:n] are consistent and add a commitment to D[0:k].
          <vspace blankLines='1' />
          SUBPROOF(m, D[n], b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k])
          <vspace blankLines='1' />
          Here, : is a concatenation of lists, and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
        </t>
        <t>
          The number of nodes in the resulting proof is bounded above by ceil(log2(n)) + 1.
        </t>
      </section>

        <section title="Example">
          <t>
            The binary Merkle Tree with 7 leaves:
<figure>
<artwork>    
            hash
           /    \
          /      \
         /        \
        /          \
       /            \
      k              l
     / \            / \
    /   \          /   \ 
   /     \        /     \    
  g       h      i      j
 / \     / \    / \     |
 a b     c d    e f     d6       
 | |     | |    | |                               
d0 d1   d2 d3  d4 d5    
</artwork>
</figure>
          </t>
          <t>
            The audit path for d0 is [b, h, l].
          </t>
          <t>
            The audit path for d3 is [c, g, l].
          </t>
          <t>
            The audit path for d4 is [f, j, k].
          </t>
          <t>
            The audit path for d6 is [i, k].
          </t>
          <t>
            The same tree, built incrementally in four steps:
<figure>
<artwork>    
    hash0          hash1=k 
    / \              /  \  
   /   \            /    \ 
  /     \          /      \ 
  g      c         g       h 
 / \     |        / \     / \ 
 a b     d2       a b     c d 
 | |              | |     | |                   
d0 d1            d0 d1   d2 d3

          hash2                    hash
          /  \                    /    \
         /    \                  /      \
        /      \                /        \
       /        \              /          \
      /          \            /            \
     k            i          k              l
    / \          / \        / \            / \
   /   \         e f       /   \          /   \
  /     \        | |      /     \        /     \    
 g       h      d4 d5    g       h      i      j
/ \     / \             / \     / \    / \     |
a b     c d             a b     c d    e f     d6       
| |     | |             | |     | |    | |                               
d0 d1   d2 d3           d0 d1   d2 d3  d4 d5    
</artwork>
</figure>
          </t>
          <t>
            The consistency proof between hash0 and hash is PROOF(3, D[7]) = [c, d, g, l]. c, g are used to verify hash0, and d, l are additionally used to show hash is consistent with hash0.
          </t>
          <t>
            The consistency proof between hash1 and hash is PROOF(4, D[7]) =
[l]. hash can be verified using hash1=k and l.
          </t>
          <t>
            The consistency proof between hash2 and hash is PROOF(6, D[7]) = [i, j, k]. k, i are used to verify hash2, and j is additionally used to show hash is consistent with hash2.
          </t>
        </section>
        <section title="Signatures">
          <t>
            Various data structures are signed. A log MUST use either elliptic
curve signatures using the NIST P-256 curve (Section D.1.2.3 of the <xref
target="DSS">Digital Signature Standard </xref>) or RSA signatures (RSASSA-PKCS1-V1_5 with SHA-256,
Section 8.2 of <xref target="RFC3447"/>) using a key of at least 2048 bits.
          </t>
        </section>
      </section>
    </section>
    <section title="Log Format and Operation">
      <t>
        Anyone can submit certificates to certificate logs for public auditing;
however, since certificates will not be accepted by TLS clients unless logged,
it is expected that certificate owners or their CAs will usually submit them. A
log is a single, ever-growing, append-only Merkle Tree of such certificates.
      </t>
      <t>
        When a valid certificate is submitted to a log, the log MUST immediately return a Signed Certificate Timestamp (SCT). The SCT is the log's promise to incorporate the certificate in the Merkle Tree within a fixed amount of time known as the Maximum Merge Delay (MMD). If the log has previously seen the certificate, it MAY return the same SCT as it returned before. TLS servers MUST present an SCT from one or more logs to the TLS client together with the certificate. TLS clients MUST reject certificates that do not have a valid SCT for the end-entity certificate.
      </t>
      <t>
        Periodically, each log appends all its new entries to the Merkle Tree and signs the root of the tree. The log MUST incorporate a certificate in its Merkle Tree within the Maximum Merge Delay period after the issuance of the SCT. When encountering an SCT, an Auditor can verify that the certificate was added to the Merkle Tree within that timeframe.
      </t>
      <t>
        Log operators MUST NOT impose any conditions on retrieving or sharing data from the log.
      </t>
      <section title="Log Entries">
        <t>
          Anyone can submit a certificate to any log. In order to enable attribution of each logged certificate to its issuer, the log SHALL publish a list of acceptable root certificates (this list might usefully be the union of root certificates trusted by major browser vendors). Each submitted certificate MUST be accompanied by all additional certificates required to verify the certificate chain up to an accepted root certificate. The root certificate itself MAY be omitted from the chain submitted to the log server.
        </t>
        <t>
          Alternatively, (root as well as intermediate) certificate authorities
may submit a certificate to logs prior to issuance in order to incorporate the
SCT in the issued certificate. To do so, the CA submits a Precertificate that
the log can use to create an entry that will be valid against the issued
certificate.  The Precertificate is an X.509v3 certificate for simplicity, but,
since it isn't used for anything but logging, could equally be some other data
structure. The Precertificate is constructed from the certificate to be issued
by adding a special critical poison extension (OID 1.3.6.1.4.1.11129.2.4.3,
whose extnValue OCTET STRING contains ASN.1 NULL data (0x05 0x00)) to the
end-entity TBSCertificate, minus the SCT extension, which is obviously unknown
until after the Precertificate has been submitted to the log. The poison
extension is to ensure that the Precertificate cannot be validated by a standard
X.509v3 client. The Precertificate MAY redact certain domain name labels that
will be present in the final certificate (see
<xref target="redacting_subdomains"/>). The resulting TBSCertificate
<xref target='RFC5280'/> is then signed with either
          <list style="symbols">
            <t>
              a special-purpose (CA:true, Extended Key Usage: Certificate Transparency, OID 1.3.6.1.4.1.11129.2.4.4) Precertificate Signing Certificate. The Precertificate Signing Certificate MUST be directly certified by the (root or intermediate) CA certificate that will ultimately sign the end-entity TBSCertificate yielding the end-entity certificate (note that the log may relax standard validation rules to allow this, so long as the issued certificate will be valid),
            </t>
            <t>
              or, the CA certificate that will sign the final certificate.
            </t>
          </list>
          As above, the Precertificate submission MUST be accompanied by the Precertificate Signing Certificate, if used, and all additional certificates required to verify the chain up to an accepted root certificate. The signature on the TBSCertificate indicates the certificate authority's intent to issue a certificate. This intent is considered binding (i.e., misissuance of the Precertificate is considered equal to misissuance of the final certificate). Each log verifies the Precertificate signature chain and issues a Signed Certificate Timestamp on the corresponding TBSCertificate.
        </t>
        <t>
          Logs MUST verify that the submitted end-entity certificate or
Precertificate has a valid signature chain leading back to a trusted root CA
certificate, using the chain of intermediate CA certificates provided by the
submitter. Logs MAY accept certificates that have expired, are not yet valid,
have been revoked, or are otherwise not fully valid according to X.509
verification rules in order to accommodate quirks of CA certificate-issuing
software. However, logs MUST refuse to publish certificates without a valid
chain to a known root CA. If a certificate is accepted and an SCT issued, the
accepting log MUST store the entire chain used for verification, including the
certificate or Precertificate itself and including the root certificate used
to verify the chain (even if it was omitted from the submission), and MUST
present this chain for auditing upon request. This chain is required to prevent
a CA from avoiding blame by logging a partial or empty chain. (Note: This effectively
excludes self-signed and DANE-based certificates until some mechanism to
control spam for those certificates is found. The authors welcome
suggestions.)
        </t>
        <t>
          Each certificate entry in a log MUST include the following components:
        </t>
<figure>
  <artwork>
    enum { x509_entry(0), precert_entry(1), (65535) } LogEntryType;

    struct {
        LogEntryType entry_type;
        select (entry_type) {
            case x509_entry: X509ChainEntry;
            case precert_entry: PrecertChainEntry;
        } entry;
    } LogEntry;

    opaque ASN.1Cert&lt;1..2^24-1&gt;;

    struct {
        ASN.1Cert leaf_certificate;
        ASN.1Cert certificate_chain&lt;0..2^24-1&gt;;
    } X509ChainEntry;

    struct {
        ASN.1Cert pre_certificate;
        ASN.1Cert precertificate_chain&lt;0..2^24-1&gt;;
    } PrecertChainEntry;
  </artwork>
</figure>
        <t>
          Logs MAY limit the length of chain they will accept.
        </t>
        <t>
          <spanx style="verb">entry_type</spanx> is the type of this entry. Future revisions of this protocol version may add new LogEntryType values. <xref target="client_messages"/> explains how clients should handle unknown entry types.
        </t>
        <t>
          <spanx style="verb">leaf_certificate</spanx> is the end-entity certificate submitted for auditing.
        </t>
        <t>
          <spanx style="verb">certificate_chain</spanx> is a chain of additional certificates required to verify the end-entity certificate. The first certificate MUST certify the end-entity certificate. Each following certificate MUST directly certify the one preceding it. The final certificate MUST be a root certificate accepted by the log.
        </t>
        <t>
          <spanx style="verb">pre_certificate</spanx> is the Precertificate submitted for auditing.
        </t>
        <t>
          <spanx style="verb">precertificate_chain</spanx> is a chain of additional certificates required to verify the Precertificate submission. The first certificate MAY be a valid Precertificate Signing Certificate and MUST certify the first certificate. Each following certificate MUST directly certify the one preceding it. The final certificate MUST be a root certificate accepted by the log.
        </t>
      </section>
      <section title="Private Domain Name Labels">
        <t>
          Enterprises regard some DNS domain name labels within their registered
domain space as private and security sensitive. Even though these domains are
often only accessible within the enterprise's private network, it's common for
them to be secured using publicly trusted TLS server certificates. Enterprises
don't want these private labels to appear in public logs.
        </t>
        <section title="Wildcard Certificates">
          <t>
            A certificate containing a <xref target="RFC6125">DNS-ID</xref> of
<spanx style="verb">*.example.com</spanx> could be used to secure the domain
<spanx style="verb">topsecret.example.com</spanx>, without revealing the string
<spanx style="verb">topsecret</spanx> publicly.
          </t>
          <t>
            Since TLS clients only match the wildcard character to the complete
leftmost label of the DNS domain name (see Section 6.4.3 of
<xref target="RFC6125"/>), this approach would not work for a DNS-ID such as
<spanx style="verb">top.secret.example.com</spanx>.  Also, wildcard certificates
are prohibited in some cases, such as <xref target="EVSSLGuidelines">Extended
Validation Certificates</xref>.
          </t>
        </section>
        <section title="Redacting Domain Name Labels in Precertificates" anchor="redacting_subdomains">
          <t>
            When creating a Precertificate, the CA MAY substitute one or more of
the complete leftmost labels in each DNS-ID with the literal string
<spanx style="verb">(PRIVATE)</spanx>. For example, if a certificate contains a
DNS-ID of <spanx style="verb">top.secret.example.com</spanx>, then the
corresponding Precertificate could contain
<spanx style="verb">(PRIVATE).example.com</spanx> instead. Labels in a
<xref target="RFC6125">CN-ID</xref> MUST remain unredacted.
          </t>
          <t>
            When a Precertificate contains one or more redacted labels, an
extension (OID 1.3.6.1.4.1.11129.2.4.6, whose extnValue OCTET STRING
contains an ASN.1 SEQUENCE OF INTEGERs) MUST be added to the corresponding
certificate: the first INTEGER indicates the number of labels redacted in the
Precertificate's first DNS-ID; the second INTEGER does the same for the
Precertificate's second DNS-ID; etc. There MUST NOT be more INTEGERs than there
are DNS-IDs. If there are fewer INTEGERs than there are DNS-IDs, the shortfall
is made up by implicitly repeating the last INTEGER. Each INTEGER MUST have a
value of zero or more. The purpose of this extension is to enable TLS clients
to accurately reconstruct the Precertificate from the certificate without
having to perform any guesswork.
          </t>
        </section>
        <section title="Using a Name-Constrained Intermediate CA">
          <t>
            An intermediate CA certificate or Precertificate that contains the
Name Constraints extension (see Section 4.2.1.10 of <xref target="RFC5280"/>)
MAY be logged in place of end-entity certificates issued by that intermediate
CA, as long as all of the following conditions are met:
            <list style="symbols">
              <t>
                there MUST be an extension (OID 1.3.6.1.4.1.11129.2.4.7,
whose extnValue OCTET STRING contains ASN.1 NULL data (0x05 0x00)). This
extension is an explicit indication that it is acceptable to not log
certificates issued by this intermediate CA.
              </t>
              <t>
                permittedSubtrees MUST specify one or more dNSNames.
              </t>
              <t>
                excludedSubtrees MUST specify the entire IPv4 and IPv6 address
ranges.
              </t>
            </list>
          </t>
          <t>
            Below is an example Name Constraints extension that meets these
conditions:
          </t>
          <figure>
            <artwork>
SEQUENCE {
  OBJECT IDENTIFIER '2 5 29 30'
  OCTET STRING, encapsulates {
    SEQUENCE {
      [0] {
        SEQUENCE {
          [2] 'example.com'
          }
        }
      [1] {
        SEQUENCE {
          [7] 00 00 00 00 00 00 00 00
          }
        SEQUENCE {
          [7]
            00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
            00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
          }
        }
      }
    }
  }
            </artwork>
          </figure>
        </section>
      </section>
      <section title="Structure of the Signed Certificate Timestamp">
        <figure>
          <artwork>
    enum { certificate_timestamp(0), tree_hash(1), (255) }
      SignatureType;

    enum { v1(0), (255) }
      Version;

      struct {
          opaque key_id[32];
      } LogID;

      opaque TBSCertificate&lt;1..2^24-1&gt;;

      struct {
        opaque issuer_key_hash[32];
        TBSCertificate tbs_certificate;
      } PreCert;

      opaque CtExtensions&lt;0..2^16-1&gt;;
          </artwork>
        </figure>
        <t>
          <spanx style="verb">key_id</spanx> is the SHA-256 hash of the log's public key, calculated over the DER encoding of the key represented as SubjectPublicKeyInfo.
        </t>
        <t>
          <spanx style="verb">issuer_key_hash</spanx> is the SHA-256 hash of the certificate issuer's public key, calculated over the DER encoding of the key represented as SubjectPublicKeyInfo. This is needed to bind the issuer to the final certificate.
        </t>
        <t>
          <spanx style="verb">tbs_certificate</spanx> is the DER-encoded
TBSCertificate (see <xref target='RFC5280'/>) component of the Precertificate --
that is, without the signature and the poison extension. If the Precertificate
is not signed with the CA certificate that will issue the final certificate,
then the TBSCertificate also has its issuer changed to that of the CA that will
issue the final certificate. Note that it is also possible to reconstruct this
TBSCertificate from the final certificate by extracting the TBSCertificate from
it and deleting the SCT extension. Also note that since the TBSCertificate
contains an AlgorithmIdentifier that must match both the Precertificate
signature algorithm and final certificate signature algorithm, they must be
signed with the same algorithm and parameters. If the Precertificate is issued
using a Precertificate Signing Certificate and an Authority Key Identifier
extension is present in the TBSCertificate, the corresponding extension must
also be present in the Precertificate Signing Certificate -- in this case, the
TBSCertificate also has its Authority Key Identifier changed to match the final
issuer.
        </t>
        <figure>
          <artwork>
    struct {
        Version sct_version;
        LogID id;
        uint64 timestamp;
        CtExtensions extensions;
        digitally-signed struct {
            Version sct_version;
            SignatureType signature_type = certificate_timestamp;            
            uint64 timestamp;
            LogEntryType entry_type;
            select(entry_type) {
                case x509_entry: ASN.1Cert;
                case precert_entry: PreCert;
            } signed_entry;
           CtExtensions extensions;
        };
    } SignedCertificateTimestamp;
          </artwork>
        </figure>
        <t>
          The encoding of the digitally-signed element is defined in <xref target='RFC5246'/>.
        </t>
        <t>
          <spanx style="verb">sct_version</spanx> is the version of the
protocol to which the SCT conforms. This version is v1.
        </t>
        <t>
          <spanx style="verb">timestamp</spanx> is the current <xref target="RFC5905">NTP Time</xref>, measured since the epoch (January 1, 1970, 00:00), ignoring leap seconds, in milliseconds.
        </t>
        <t>
          <spanx style="verb">entry_type</spanx> may be implicit from the context in which the SCT is presented.
        </t>
        <t>
          <spanx style="verb">signed_entry</spanx> is the <spanx
style="verb">leaf_certificate</spanx> (in the case of an X509ChainEntry) or is the
PreCert (in the case of a PrecertChainEntry), as described above.
        </t>
        <t>
          <spanx style="verb">extensions</spanx> are future extensions to this protocol version (v1). Currently, no extensions are specified.
        </t>
      </section>

      <section title="Including the Signed Certificate Timestamp in the TLS Handshake">
        <t>
The SCT data corresponding to the end-entity certificate from at
least one log must be included in the TLS handshake, either by using
an X509v3 certificate extension as described below, by using a TLS
extension
(Section 7.4.1.4 of <xref target='RFC5246'/>) 
with type
"signed_certificate_timestamp", or by using Online Certificate
Status Protocol (OCSP) Stapling (also known as the "Certificate
Status Request" TLS extension; see 
<xref target='RFC6066'/>), where the OCSP response includes an
extension with OID 1.3.6.1.4.1.11129.2.4.5 (see <xref target='RFC2560'/>) and
body:


        </t>
        <figure>
          <artwork>
    SignedCertificateTimestampList ::= OCTET STRING</artwork></figure>
        <t>
          in the singleExtensions component of the SingleResponse pertaining to the end-entity certificate.
        </t>
        <t>
          At least one SCT MUST be included. Server operators MAY include more than one SCT.
        </t>
        <t>
          Similarly, a certificate authority MAY submit a Precertificate to more than one log, and all obtained SCTs can be directly embedded in the final certificate, by encoding the SignedCertificateTimestampList structure as an ASN.1 OCTET STRING and inserting the resulting data in the TBSCertificate as an X.509v3 certificate extension (OID 1.3.6.1.4.1.11129.2.4.2). Upon receiving the certificate, clients can reconstruct the original TBSCertificate to verify the SCT signature.
        </t>
        <t>
          The contents of the ASN.1 OCTET STRING embedded in an OCSP extension or X509v3 certificate extension are as follows:
        </t>
        <figure>
          <artwork>
     opaque SerializedSCT&lt;1..2^16-1&gt;; 

     struct {
         SerializedSCT sct_list &lt;1..2^16-1&gt;;
     } SignedCertificateTimestampList;
          </artwork>
        </figure>
        <t>
          Here, <spanx style="verb">SerializedSCT</spanx> is an opaque
byte string that contains the serialized SCT structure. This encoding ensures
that TLS clients can decode each SCT individually (i.e., if there is a version
upgrade, out-of-date clients can still parse old SCTs while skipping over new
SCTs whose versions they don't understand).
        </t>
        <t>
          Likewise, SCTs can be embedded in a TLS extension. See below for details.
        </t>
        <t>
          TLS clients MUST implement all three mechanisms. Servers MUST implement at least one of the three mechanisms. Note that existing TLS servers can generally use the certificate extension mechanism without modification.
        </t>
        <t>
          TLS servers should send SCTs from multiple logs in case one or more
logs are not acceptable to the client (for example, if a log has been struck off
for misbehavior or has had a key compromise).

        </t>
        <section title="TLS Extension">
          <t>
            The SCT can be sent during the TLS handshake using a TLS extension with type "signed_certificate_timestamp".
          </t>
          <t>
            Clients that support the extension SHOULD send a ClientHello extension with the appropriate type and empty <spanx style="verb">extension_data</spanx>.
          </t>
          <t>
            Servers MUST only send SCTs to clients who have indicated support for the extension in the ClientHello, in which case the SCTs are sent by setting the <spanx style="verb">extension_data</spanx> to a <spanx style="verb">SignedCertificateTimestampList</spanx>.
          </t>
          <t>
            Session resumption uses the original session information: clients SHOULD include the extension type in the ClientHello, but if the session is resumed, the server is not expected to process it or include the extension in the ServerHello.
          </t>
        </section>
      </section>
      <section title="Merkle Tree" anchor="tree">
        <t>
          The hashing algorithm for the Merkle Tree Hash is SHA-256.
        </t>
        <t>
          Structure of the Merkle Tree input:
        </t>
<figure>
  <artwork>
    enum { timestamped_entry(0), (255) }
      MerkleLeafType;

    struct {
        uint64 timestamp;
        LogEntryType entry_type;
        select(entry_type) {
            case x509_entry: ASN.1Cert;
            case precert_entry: PreCert;
        } signed_entry;
        CtExtensions extensions;
    } TimestampedEntry;

    struct {
        Version version;
        MerkleLeafType leaf_type;
        select (leaf_type) {
            case timestamped_entry: TimestampedEntry;  
        }    
    } MerkleTreeLeaf;
  </artwork>
</figure>
        <t>
          Here, <spanx style="verb">version</spanx> is the version of the
protocol to which the MerkleTreeLeaf corresponds. This version is v1.
        </t>
        <t>
          <spanx style="verb">leaf_type</spanx> is the type of the leaf input. Currently, only <spanx style="verb">timestamped_entry</spanx> (corresponding to an SCT) is defined. Future revisions of this protocol version may add new MerkleLeafType types. <xref target="client_messages"/> explains how clients should handle unknown leaf types.
        </t>
        <t>
          <spanx style="verb">timestamp</spanx> is the timestamp of the corresponding SCT issued for this certificate.
        </t>
        <t>
          <spanx style="verb">signed_entry</spanx> is the <spanx style="verb">signed_entry</spanx> of the corresponding SCT.
        </t>
        <t>
          <spanx style="verb">extensions</spanx> are <spanx style="verb">extensions</spanx> of the corresponding SCT.
        </t>
        <t>
          The leaves of the Merkle Tree are the leaf hashes of the corresponding <spanx style="verb">MerkleTreeLeaf</spanx> structures.
        </t>
      </section>
      <section title="Signed Tree Head">
        <t>
        Every time a log appends new entries to the tree, the log SHOULD sign the corresponding tree hash and tree information (see the corresponding Signed Tree Head client message in <xref target="fetch_sth"/>). The signature for that data is structured as follows:
        </t>

<figure>
  <artwork>
    opaque CtSthExtensions&lt;0..2^16-1&gt;;

    digitally-signed struct {
        Version version;
        SignatureType signature_type = tree_hash;
        uint64 timestamp;
        uint64 tree_size;
        opaque sha256_root_hash[32];
        CtSthExtensions extensions;
    } TreeHeadSignature;
  </artwork>
</figure>

        <t>
          <spanx style="verb">version</spanx> is the version of the protocol to
which the TreeHeadSignature conforms. This version is v1.
        </t>
        <t>
          <spanx style="verb">timestamp</spanx> is the current time. The timestamp MUST be at least as recent as the most recent SCT timestamp in the tree. Each subsequent timestamp MUST be more recent than the timestamp of the previous update.
        </t>
        <t>
          <spanx style="verb">tree_size</spanx> equals the number of entries in the new tree.
        </t>
        <t>
          <spanx style="verb">sha256_root_hash</spanx> is the root of the Merkle Hash Tree.
        </t>
        <t>
          <spanx style="verb">extensions</spanx> are future extensions to this protocol version (v1). Currently, no extensions are specified.
        </t>
        <t>Each log MUST produce on demand a Signed Tree Head that is no older than the Maximum Merge Delay. In the unlikely event that it receives no new submissions during an MMD period, the log SHALL sign the same Merkle Tree Hash with a fresh timestamp.
        </t>
      </section>
    </section>
    <section title="Log Client Messages" anchor="client_messages">
      <t>
        Messages are sent as HTTPS GET or POST requests. Parameters for POSTs
and all responses are encoded as <xref target="RFC4627">JavaScript Object
Notation (JSON)
objects</xref>. Parameters for GETs are encoded as order-independent key/value
URL parameters, using the "application/x-www-form-urlencoded" format described
in the <xref target="HTML401">"HTML 4.01 Specification"</xref>. Binary data is
<xref target="RFC4648">base64 encoded</xref> as specified in the individual
messages.
      </t>
      <t>
        Note that JSON objects and URL parameters may contain fields not specified here. These extra fields should be ignored.
      </t>
      <t>
        The &lt;log server&gt; prefix can include a path as well as a server name and a port.
      </t>
      <t>
        In general, where needed, the <spanx style="verb">version</spanx> is v1 and the <spanx style="verb">id</spanx> is the log id for the log server queried.
      </t>
      <t>
        If the log is unable to process a client's request, it MUST return an HTTP response code of 4xx/5xx (see <xref target="RFC2616"/>), and, in place of the responses outlined in the subsections below, the body SHOULD be a JSON structure containing at least the following field:
        <list style="hanging">
          <t hangText="error_message:">
            <list>
              <t>
                A human-readable string describing the error which prevented the log from processing the request.
              </t>
              <t>
                In the case of a malformed request, the string SHOULD provide sufficient detail for the error to be rectified.
              </t>
            </list>
          </t>
        </list>
      </t>
      <t>
        <figure>
          <preamble>
            e.g. In response to a request of <spanx style="verb">/ct/v1/get-entries?start=100&amp;end=99</spanx>, the log would return a <spanx style="verb">400 Bad Request</spanx> response code with a body similar to the following:
          </preamble>
          <artwork>
  {
    "error_message": "'start' cannot be greater than 'end'",
  }
          </artwork>
        </figure>
      </t>
      <t>
        Clients SHOULD treat <spanx style="verb">500 Internal Server Error</spanx> and <spanx style="verb">503 Service Unavailable</spanx> responses as transient failures and MAY retry the same request without modification at a later date.  Note that as per <xref target="RFC2616"/>, in the case of a 503 response the log MAY include a <spanx style="verb">Retry-After:</spanx> header in order to request a minimum time for the client to wait before retrying the request.
      </t>
      <section title="Add Chain to Log" anchor="sct">
        <t>
          POST https://&lt;log server&gt;/ct/v1/add-chain
        </t>

        <t>
          Inputs:

	  <list>
	    <t><list style="hanging">
	      <t hangText="chain:">
		An array of base64-encoded certificates. The first element is the end-entity certificate; the second chains to the first and so on to the last, which is either the root certificate or a certificate that chains to a known root certificate.
	      </t>
	    </list></t>
	  </list>
        </t>

        <t>
          Outputs:

          <list>
	    <t><list style="hanging">
	      <t hangText="sct_version:">
		The version of the SignedCertificateTimestamp structure, in decimal. A compliant v1 implementation MUST NOT expect this to be 0 (i.e., v1).
	      </t>
	      <t hangText="id:">
		The log ID, base64 encoded.
	      </t>
	      <t hangText="timestamp:">
		The SCT timestamp, in decimal.
	      </t>
	      <t hangText="extensions:">
		An opaque type for future expansion. It is likely that not all participants will need to understand data in this field. Logs should set this to the empty string. Clients should decode the base64-encoded data and include it in the SCT.
	      </t>
	      <t hangText="signature:">
		The SCT signature, base64 encoded.
	      </t>
            </list></t>
	  </list>

          If the <spanx style="verb">sct_version</spanx> is not v1, then a v1 client may be unable to verify the signature. It MUST NOT construe this as an error. This is to avoid forcing an upgrade of compliant v1 clients that do not use the returned SCTs.

        </t>
      </section>
      <section title="Add PreCertChain to Log">
        <t>
          POST https://&lt;log server&gt;/ct/v1/add-pre-chain
        </t>
        <t>
          Inputs:

          <list>
	    <t><list style="hanging">
              <t hangText="chain:">
		An array of base64-encoded Precertificates. The first element is the end-entity certificate; the second chains to the first and so on to the last, which is either the root certificate or a certificate that chains to a known root certificate.
              </t>
            </list></t>
          </list>
        </t>
        <t>
          Outputs are the same as in <xref target="sct"/>.
        </t>
      </section>

      <section title="Retrieve Latest Signed Tree Head" anchor="fetch_sth">
        <t>
          GET https://&lt;log server&gt;/ct/v1/get-sth
        </t>
        <t>
          No inputs.
        </t>
        <t>
          Outputs:

          <list>
	    <t><list style="hanging">
	      <t hangText="tree_size:">
		The size of the tree, in entries, in decimal.
	      </t>
	      <t hangText="timestamp:">
		The timestamp, in decimal.
	      </t>
	      <t hangText="sha256_root_hash:">
		The Merkle Tree Hash of the tree, in base64.
	      </t>
	      <t hangText="tree_head_signature:">
		A TreeHeadSignature for the above data.
	      </t>
            </list></t>
          </list>
        </t>
      </section>

      <section title="Retrieve Merkle Consistency Proof between Two Signed Tree Heads" anchor="fetch_consistency">
        <t>
          GET https://&lt;log server&gt;/ct/v1/get-sth-consistency
        </t>
        <t>
          Inputs:

          <list>
	    <t><list style="hanging">
	      <t hangText="first:">
		The tree_size of the older tree, in decimal.
	      </t>
	      <t hangText="second:">
		The tree_size of the newer tree, in decimal.
	      </t>
            </list></t>
          </list>

          Both tree sizes must be from existing v1 STHs (Signed Tree Heads).
        </t>
        <t>
          Outputs:

        <list>
	  <t><list style="hanging">
            <t hangText="consistency:">
	      An array of Merkle Tree nodes, base64 encoded.
            </t>
          </list></t>
        </list>

          Note that no signature is required on this data, as it is used to verify an STH, which is signed.
        </t>
      </section>

      <section title="Retrieve Merkle Audit Proof from Log by Leaf Hash" anchor="fetch_proof">
        <t>
          GET https://&lt;log server&gt;/ct/v1/get-proof-by-hash
        </t>
        <t>
          Inputs:

          <list>
	    <t><list style="hanging">
	      <t hangText="hash:">
		A base64-encoded v1 leaf hash.
	      </t>
	      <t hangText="tree_size:">
		The tree_size of the tree on which to base the proof, in decimal.
	      </t>
            </list></t>
	  </list>

          The <spanx style="verb">hash</spanx> must be calculated as defined in <xref target="tree"/>. The <spanx style="verb">tree_size</spanx> must designate an existing v1 STH.
        </t>

        <t>
          Outputs:

          <list>
	    <t><list style="hanging">
	      <t hangText="leaf_index:">
		The 0-based index of the entry corresponding to the <spanx style="verb">hash</spanx> parameter.
	      </t>
	      <t hangText="audit_path:">
		An array of base64-encoded Merkle Tree nodes proving the inclusion of the chosen certificate.
	      </t>
            </list></t>
          </list>
        </t>
      </section>

      <section title="Retrieve Entries from Log" anchor="fetch_entries">
        <t>
          GET https://&lt;log server&gt;/ct/v1/get-entries
        </t>
        <t>
          Inputs:

          <list>
            <t><list style="hanging">
              <t hangText="start:">
		0-based index of first entry to retrieve, in decimal.
              </t>
              <t hangText="end:">
		0-based index of last entry to retrieve, in decimal.
              </t>
            </list></t>
          </list>
        </t>

        <t>
          Outputs:

          <list>
            <t><list style="hanging">
              <t hangText="entries:">
		An array of objects, each consisting of
		<list style="hanging">
                  <t hangText="leaf_input:">
                    The base64-encoded MerkleTreeLeaf structure.
                  </t>
                  <t hangText="extra_data:">
                    The base64-encoded unsigned data pertaining to the log entry. In the case of an X509ChainEntry, this is the <spanx style="verb">certificate_chain</spanx>. In the case of a PrecertChainEntry, this is the whole <spanx style="verb">PrecertChainEntry</spanx>.
                  </t>
		</list>
	      </t>
            </list></t>
        </list>
        </t>

        <t>
          Note that this message is not signed -- the retrieved data can be
verified by constructing the Merkle Tree Hash corresponding to a retrieved
STH. All leaves MUST be v1. However, a compliant v1 client MUST NOT construe an
unrecognized MerkleLeafType or LogEntryType value as an error. This means it
may be unable to parse some entries, but note that each client can inspect the
entries it does recognize as well as verify the integrity of the data by
treating unrecognized leaves as opaque input to the tree.
        </t>
        <t>
          The <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> parameters SHOULD be within the range 0 &lt;= x &lt; <spanx style="verb">tree_size</spanx> as returned by <spanx style="verb">get-sth</spanx> in <xref target="fetch_sth"/>.
        </t>
        <t>
          Logs MAY honor requests where 0 &lt;= <spanx style="verb">start</spanx> &lt; <spanx style="verb">tree_size</spanx> and <spanx style="verb">end</spanx> &gt;= <spanx style="verb">tree_size</spanx> by returning a partial response covering only the valid entries in the specified range. Note that the following restriction may also apply:
        </t>
        <t>
          Logs MAY restrict the number of entries that can be retrieved per
<spanx style="verb">get-entries</spanx> request.  If a client requests more
than the permitted number of entries, the log SHALL return the maximum number
of entries permissible. These entries SHALL be sequential beginning with the
entry specified by <spanx style="verb">start</spanx>.
        </t>
      </section>
      <section title="Retrieve Accepted Root Certificates">
        <t>
          GET https://&lt;log server&gt;/ct/v1/get-roots
        </t>
        <t>
          No inputs.
        </t>
        <t>
          Outputs:

          <list>
            <t><list style="hanging">
              <t hangText="certificates:">
		An array of base64-encoded root certificates that are acceptable to the log.
              </t>
            </list></t>
          </list>
        </t>
      </section>

      <section title="Retrieve Entry+Merkle Audit Proof from Log">
        <t>
          GET https://&lt;log server&gt;/ct/v1/get-entry-and-proof
        </t>
        <t>
          Inputs:

          <list>
            <t><list style="hanging">
              <t hangText="leaf_index:">
		The index of the desired entry.
              </t>
              <t hangText="tree_size:">
		The tree_size of the tree for which the proof is desired.
              </t>
            </list></t>
          </list>

          The tree size must designate an existing STH.
        </t>
        <t>
          Outputs:

          <list>
            <t><list style="hanging">
              <t hangText="leaf_input:">
		The base64-encoded MerkleTreeLeaf structure.
              </t>
              <t hangText="extra_data:">
		The base64-encoded unsigned data, same as in <xref target='fetch_entries'/>.
              </t>
              <t hangText="audit_path:">
		An array of base64-encoded Merkle Tree nodes proving the inclusion of the chosen certificate.
              </t>
            </list></t>
          </list>

          This API is probably only useful for debugging.
        </t>
      </section>
    </section>

    <section title="Clients">
      <t>
        There are various different functions clients of logs might perform. We
describe here some typical clients and how they could function. Any
inconsistency may be used as evidence that a log has not behaved correctly, and
the signatures on the data structures prevent the log from denying that
misbehavior.

      </t>
      <t>
        All clients should gossip with each other, exchanging STHs at least;
this is all that is required to ensure that they all have a consistent
view. The exact mechanism for gossip will be described in a separate document,
but it is expected there will be a variety.
      </t>
      <section title="Submitters">
        <t>
          Submitters submit certificates or Precertificates to the log as described above. When a Submitter intends to use the returned SCT directly in a TLS handshake or to construct a certificate, they SHOULD validate the SCT as described in <xref target="tls_clients"/> if they understand its format.
        </t>
      </section>
      <section title="TLS Client" anchor="tls_clients">
        <t>
          TLS clients receive SCTs alongside or in server certificates. In
addition to normal validation of the certificate and its chain, TLS clients
SHOULD validate the SCT by computing the signature input from the SCT data as
well as the certificate and verifying the signature, using the corresponding
log's public key.
          TLS clients MAY audit the corresponding log by requesting, and
verifying, a Merkle audit proof for said certificate.
          Note that this document does not describe how clients obtain the
logs' public keys or URLs.
        </t>
        <t>
          TLS clients MUST reject SCTs whose timestamp is in the future.
        </t>
      </section>
      <section title="Monitor">
        <t>
          Monitors watch logs and check that they behave correctly. They also watch for certificates of interest.
        </t>
        <t>
          A monitor needs to, at least, inspect every new entry in each log it watches. It may also want to keep copies of entire logs. In order to do this, it should follow these steps for each log:
          <list style="numbers">
            <t>
              Fetch the current STH (<xref target="fetch_sth"/>).
            </t>
            <t>
              Verify the STH signature.
            </t>
            <t>
              Fetch all the entries in the tree corresponding to the STH (<xref target="fetch_entries"/>).
            </t>
            <t>
              Confirm that the tree made from the fetched entries produces the same hash as that in the STH.
            </t>
            <t anchor="monitor_loop">
              Fetch the current STH (<xref target="fetch_sth"/>). Repeat until
the STH changes.
            </t>
            <t>
              Verify the STH signature.
            </t>
            <t>
              Fetch all the new entries in the tree corresponding to the STH
(<xref target="fetch_entries"/>). If they remain unavailable for an extended period, then this should be viewed as misbehavior on the part of the log.
            </t>
            <t>
              Either:
              <list style="numbers">
                <t>
                  Verify that the updated list of all entries generates a tree with the same hash as the new STH.
                </t>
              </list>
              Or, if it is not keeping all log entries:
              <list style="numbers">
                <t>
                  Fetch a consistency proof for the new STH with the previous STH (<xref target="fetch_consistency"/>).
                </t>
                <t>
                  Verify the consistency proof.
                </t>
                <t>
                  Verify that the new entries generate the corresponding elements in the consistency proof.
                </t>
              </list>
            </t>
            <t>
              Go to Step 5.
            </t>
          </list>
        </t>
      </section>
      <section title="Auditor">
        <t>
          Auditors take partial information about a log as input and verify
that this information is consistent with other partial information they
have. An auditor might be an integral component of a TLS client; it might be a
standalone service; or it might be a secondary function of a monitor.
        </t>
        <t>
          Any pair of STHs from the same log can be verified by requesting a consistency proof (<xref target="fetch_consistency"/>).
        </t>
        <t>
          A certificate accompanied by an SCT can be verified against any STH dated after the SCT timestamp + the Maximum Merge Delay by requesting a Merkle audit proof (<xref target="fetch_proof"/>).
        </t>
        <t>
          Auditors can fetch STHs from time to time of their own accord, of course (<xref target="fetch_sth"/>).
        </t>
      </section>
    </section>

    <section title="IANA Considerations">
      <t>
        IANA has allocated an RFC 5246 ExtensionType value (18) for the SCT TLS
        extension. The extension name is "signed_certificate_timestamp".


      </t>
    </section>

    <section title="Security Considerations">
      <t>
        With CAs, logs, and servers performing the actions described here, TLS clients can use logs and signed timestamps to reduce the likelihood that they will accept misissued certificates.  If a server presents a valid signed timestamp for a certificate, then the client knows that the certificate has been published in a log.  From this, the client knows that the subject of the certificate has had some time to notice the misissue and take some action, such as asking a CA to revoke a misissued certificate.  A signed timestamp is not a guarantee that the certificate is not misissued, since the subject of the certificate might not have checked the logs or the CA might have refused to revoke the certificate.
      </t>
      <t>
        In addition, if TLS clients will not accept unlogged certificates, then site owners will have a greater incentive to submit certificates to logs, possibly with the assistance of their CA, increasing the overall transparency of the system.
      </t>
      <section title="Misissued Certificates">
        <t>
          Misissued certificates that have not been publicly logged, and thus do not have a valid SCT, will be rejected by TLS clients. Misissued certificates that do have an SCT from a log will appear in that public log within the Maximum Merge Delay, assuming the log is operating correctly. Thus, the maximum period of time during which a misissued certificate can be used without being available for audit is the MMD. 
        </t>
      </section>
      <section title="Detection of Misissue">
        <t>
          The logs do not themselves detect misissued certificates; they rely
instead on interested parties, such as domain owners, to monitor them and take
corrective action when a misissue is detected.
        </t>
      </section>
      <section title="Redaction of Public Domain Name Labels">
        <t>
          CAs SHOULD NOT redact domain name labels in Precertificates to the
extent that domain name ownership becomes unclear
(e.g. <spanx style="verb">(PRIVATE).com</spanx> and
<spanx style="verb">(PRIVATE).co.uk</spanx> would both be problematic). Logs
MUST NOT reject any Precertificate that is overly redacted but which is
otherwise considered compliant. It is expected that monitors will treat overly
redacted Precertificates as potentially misissued. TLS clients MAY reject a
certificate whose corresponding Precertificate would be overly redacted.
        </t>
      </section>
      <section title="Misbehaving Logs">
        <t>
          A log can misbehave in two ways: (1) by failing to incorporate a
certificate with an SCT in the Merkle Tree within the MMD and (2) by
violating its append-only property by presenting two different, conflicting
views of the Merkle Tree at different times and/or to different parties. Both
forms of violation will be promptly and publicly detectable.
        </t>
        <t>
          Violation of the MMD contract is detected by log clients requesting a
Merkle audit proof for each observed SCT. These checks can be asynchronous and
need only be done once per each certificate. In order to protect the clients'
privacy, these checks need not reveal the exact certificate to the log. Clients
can instead request the proof from a trusted auditor (since anyone can compute
the audit proofs from the log) or request Merkle proofs for a batch of
certificates around the SCT timestamp. 
        </t>
        <t>
          Violation of the append-only property is detected by global gossiping, i.e., everyone auditing logs comparing their versions of the latest Signed Tree Heads. As soon as two conflicting Signed Tree Heads for the same log are detected, this is cryptographic proof of that log's misbehavior.
        </t>
      </section>
    </section>
    <section title="Efficiency Considerations">
      <t>
        The Merkle Tree design serves the purpose of keeping communication overhead low.
      </t>
      <t>
        Auditing logs for integrity does not require third parties to maintain a copy of each entire log. The Signed Tree Heads can be updated as new entries become available, without recomputing entire trees. Third-party auditors need only fetch the Merkle consistency proofs against a log's existing STH to efficiently verify the append-only property of updates to their Merkle Trees, without auditing the entire tree.
      </t>
    </section>

    <section title="Future Changes">
      <t>
        This section lists things we might address in a Standards Track version of this document.
      
<list style="symbols">
      <t>
        Rather than forcing a log operator to create a new log in order to change the log signing key, we may allow some key roll mechanism.
      </t>
      <t>
        We may add hash and signing algorithm agility.
      </t>
      <t>
        We may describe some gossip protocols.
      </t>
</list>
</t>
    </section>
    <section title="Acknowledgements">
      <t>
        The authors would like to thank Erwann Abelea, Robin Alden, Al Cutter,
Francis Dupont, Stephen Farrell, Brad Hill, Jeff Hodges, Paul Hoffman, Jeffrey
Hutzelman, SM, Alexey Melnikov, Chris Palmer, Trevor Perrin, Ryan Sleevi and
Carl Wallace for their valuable contributions.
      </t>
    </section>
  </middle>
  <back>



    <references title="Normative Reference">

    <?rfc include="reference.RFC.2119" ?>

</references>

<references title="Informative References">

    <?rfc include="reference.RFC.2616"?>

    <?rfc include="reference.RFC.2560"?>

    <?rfc include="reference.RFC.3447"?>

    <?rfc include="reference.RFC.4627"?>

    <?rfc include="reference.RFC.4648"?>

    <?rfc include="reference.RFC.5246"?>

    <?rfc include="reference.RFC.5280"?>

    <?rfc include="reference.RFC.5905"?>

    <?rfc include="reference.RFC.6066"?>

    <?rfc include="reference.RFC.6125"?>

      <reference anchor="DSS" target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">
        <front>
          <title>Digital Signature Standard (DSS)</title>
          <author>
            <organization abbrev="NIST">National Institute of Standards and
Technology</organization>
          </author>
          <date month="June" year="2009"/>
        </front>
        <seriesInfo name="FIPS" value="186-3"/>
        <format type="PDF" target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf"/>
      </reference>

      <reference anchor="CrosbyWallach"
target="http://static.usenix.org/event/sec09/tech/full_papers/crosby.pdf">
        <front>
          <title>Efficient Data Structures for Tamper-Evident Logging</title>
          <author initials='S.' surname='Crosby' fullname='Scott A. Crosby'>
            <organization/>
          </author>
          <author initials='D.' surname='Wallach' fullname='Dan S. Wallach'>
            <organization/>
          </author>
          <date month="August" year="2009"/>
        </front>
<seriesInfo name="Proceedings of the 18th USENIX Security Symposium,"
value="Montreal"/>
        <format type="PDF" target="http://static.usenix.org/event/sec09/tech/full_papers/crosby.pdf"/>
      </reference>

      <reference anchor="HTML401" target="http://www.w3.org/TR/1999/REC-html401-19991224">
        <front>
          <title>HTML 4.01 Specification</title>
          <author initials="D." surname="Raggett" fullname="David Raggett">
            <organization/>
          </author>
          <author initials="A." surname="Le Hors" fullname="Arnaud Le Hors">
            <organization/>
          </author>
          <author initials="I." surname="Jacobs" fullname="Ian Jacobs">
            <organization/>
          </author>
          <date month="December" day="24" year="1999"/>
        </front>
        <seriesInfo name="World Wide Web Consortium Recommendation" value="REC-html401-19991224"/>
        <format type="HTML" target="http://www.w3.org/TR/1999/REC-html401-19991224"/>
      </reference>


      <reference anchor="FIPS.180-4"
target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
        <front>
          <title>Secure Hash Standard</title>
          <author>
            <organization>National Institute of Standards and Technology</organization>
          </author>
          <date month="March" year="2012"/>
        </front>
        <seriesInfo name="FIPS" value="PUB 180-4"/>
      </reference>

      <reference anchor="EVSSLGuidelines" target="https://cabforum.org/wp-content/uploads/EV_Certificate_Guidelines.pdf">
        <front>
          <title>Guidelines For The Issuance And Management Of Extended Validation Certificates</title>
          <author>
            <organization>CA/Browser Forum</organization>
          </author>
          <date year="2007"/>
        </front>
        <format type="PDF" target="https://cabforum.org/wp-content/uploads/EV_Certificate_Guidelines.pdf"/>
      </reference>

    </references>
  </back>
</rfc>
