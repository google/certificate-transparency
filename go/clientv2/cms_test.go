package clientv2

import (
	"encoding/hex"
	"math/big"
	"reflect"
	"strings"
	"testing"

	"github.com/google/certificate-transparency/go/asn1"
	"github.com/google/certificate-transparency/go/testdata"
	"github.com/google/certificate-transparency/go/x509/pkix"
)

func TestCMSExtractPrecert(t *testing.T) {
	// Make some broken copies of the valid precert.
	wrongOID := testPrecert()
	wrongOID.EncapContentInfo.EContentType = asn1.ObjectIdentifier{1, 2, 3, 4, 5}
	hasCerts := testPrecert()
	hasCerts.Certificates = CertificatesSET{
		asn1.RawValue{
			Class:     asn1.ClassUniversal,
			Tag:       asn1.TagOctetString,
			Bytes:     testdata.FromHex(testdata.AbcdSHA256),
			FullBytes: fullBytes(byte(asn1.TagOctetString), testdata.FromHex(testdata.AbcdSHA256)),
		},
	}
	noSignerInfo := testPrecert()
	noSignerInfo.SignerInfos = SignerInfosSET{}
	multipleOIDAttrValue := testPrecert()
	attrValues := &multipleOIDAttrValue.SignerInfos[0].SignedAttributes[0].AttrValues
	*attrValues = append(*attrValues, (*attrValues)[0])
	wrongOIDAttrValue := testPrecert()
	wrongOIDAttrValue.SignerInfos[0].SignedAttributes[0].AttrValues = AttrValuesSET{
		asn1.RawValue{
			Class:     asn1.ClassUniversal,
			Tag:       asn1.TagOID,
			Bytes:     []byte{0x2b, 0x65, 0x11},
			FullBytes: fullBytes(byte(asn1.TagOID), []byte{0x2b, 0x65, 0x11}),
		},
	}
	nonOIDAttrValue := testPrecert()
	nonOIDAttrValue.SignerInfos[0].SignedAttributes[0].AttrValues = AttrValuesSET{
		asn1.RawValue{
			Class:     asn1.ClassUniversal,
			Tag:       asn1.TagOctetString, // Not OID
			Bytes:     []byte{0x2b, 0x65, 0x11},
			FullBytes: fullBytes(byte(asn1.TagOctetString), []byte{0x2b, 0x65, 0x11}),
		},
	}
	multipleDigestAttrValue := testPrecert()
	attrValues = &multipleDigestAttrValue.SignerInfos[0].SignedAttributes[1].AttrValues
	*attrValues = append(*attrValues, (*attrValues)[0])
	nonOctetStringAttrValue := testPrecert()
	nonOctetStringAttrValue.SignerInfos[0].SignedAttributes[1].AttrValues = AttrValuesSET{
		asn1.RawValue{
			Class:     asn1.ClassUniversal,
			Tag:       asn1.TagOID, // Not OCTET STRING
			Bytes:     []byte{0x2b, 0x65, 0x11},
			FullBytes: fullBytes(byte(asn1.TagOID), []byte{0x2b, 0x65, 0x11}),
		},
	}
	noContentType := testPrecert()
	noContentType.SignerInfos[0].SignedAttributes = noContentType.SignerInfos[0].SignedAttributes[1:]
	noDigest := testPrecert()
	noDigest.SignerInfos[0].SignedAttributes = noDigest.SignerInfos[0].SignedAttributes[:1]

	var tests = []struct {
		in     string // hex-encoded
		want   *CMSSignedData
		errstr string
	}{
		{"", nil, "failed to parse"},
		{testCMSPrecertHex, &testCMSPrecert, ""},
		{testCMSPrecertHex + "020100", &testCMSPrecert, "trailing data"},
		{m2h(wrongOID), nil, "unexpected content OID"},
		{m2h(hasCerts), nil, "unexpected certificates"},
		{m2h(noSignerInfo), nil, "signer-infos present"},
		{m2h(multipleOIDAttrValue), nil, "content-type attribute with unexpected number"},
		{m2h(wrongOIDAttrValue), nil, "incorrect OID"},
		{m2h(nonOIDAttrValue), nil, "failed to decode content-type OID"},
		{m2h(multipleDigestAttrValue), nil, "message-digest attribute with unexpected number"},
		{m2h(nonOctetStringAttrValue), nil, "message-digest attribute value of wrong type"},
		{m2h(noContentType), nil, "missing required content-type"},
		{m2h(noDigest), nil, "missing required message-digest"},
	}

	for _, test := range tests {
		input, _ := hex.DecodeString(test.in)
		got, err := CMSExtractPrecert(input)
		if test.errstr != "" {
			if err == nil {
				t.Errorf("cmsExtractPrecert(%q)=%+v,nil; want error %q", test.in, got, test.errstr)
			} else if !strings.Contains(err.Error(), test.errstr) {
				t.Errorf("cmsExtractPrecert(%q)=nil,%q; want error %q", test.in, err.Error(), test.errstr)
			}
			continue
		}
		if err != nil {
			t.Errorf("cmsExtractPrecert(%q)=nil,%q; want %+v", test.in, err.Error(), test.want)
		} else if !reflect.DeepEqual(got, test.want) {
			t.Errorf("cmsExtractPrecert(%q)=%+v,nil; want %+v", test.in, got, test.want)
		}
	}
}

// Test data.  Generated from precert.ascii using the the ascii2der tool from
// github.com/google/der-ascii.
var testCMSPrecertHex = "3082010a020103310d300b06092a864886f70d01010b300d06032b654ea00604" +
	"04616263643181e63081e302010330793071310b300906035504061302474231" +
	"0f300d060355040813064c6f6e646f6e310f300d060355040713064c6f6e646f" +
	"6e310f300d060355040a1306476f6f676c65310c300a060355040b1303456e67" +
	"3121301f0603550403131846616b654365727469666963617465417574686f72" +
	"69747902040406cafe300b0609608648016503040201a045301206092a864886" +
	"f70d010903310506032b654e302f06092a864886f70d0109043122042088d426" +
	"6fd4e6338d13b845fcf289579d209c897823b9217da3e161936f031589300b06" +
	"092a864886f70d01010b0402abcd"

// Generated by running asn1.Marshal on testCMSPrecert below.
var testCMSPrecertMarshalled = "3082010a020103310d300b06092a864886f70d01010b300d06032b654ea0060404616263643181e63081e302010330793071310b3009060355040613024742310f300d060355040813064c6f6e646f6e310f300d060355040713064c6f6e646f6e310f300d060355040a1306476f6f676c65310c300a060355040b1303456e673121301f0603550403131846616b654365727469666963617465417574686f7269747902040406cafe300b0609608648016503040201a045301206092a864886f70d010903310506032b654e302f06092a864886f70d0109043122042088d4266fd4e6338d13b845fcf289579d209c897823b9217da3e161936f031589300b06092a864886f70d01010b0402abcd"

// Make a copy of the test precertificate.
func testPrecert() CMSSignedData {
	data, err := asn1.Marshal(testCMSPrecert)
	if err != nil {
		panic("Failed to marshal test precertificate: " + err.Error())
	}
	var result CMSSignedData
	if rest, err := asn1.Unmarshal(data, &result); err != nil {
		panic("Failed to re-unmarshal test precertificate: " + err.Error())
	} else if len(rest) > 0 {
		panic("Excess data on re-unmarshalling test precertificate")
	}
	return result
}

// Marshal a precertificate to a hex string.
func m2h(precert CMSSignedData) string {
	data, err := asn1.Marshal(precert)
	if err != nil {
		panic("Failed to marshal test precertificate: " + err.Error())
	}
	return hex.EncodeToString(data)
}

var testCMSPrecert = CMSSignedData{
	Version: 3,
	DigestAlgorithms: []pkix.AlgorithmIdentifier{
		pkix.AlgorithmIdentifier{Algorithm: asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 11}},
	},
	EncapContentInfo: EncapsulatedContentInfo{
		EContentType: asn1.ObjectIdentifier{1, 3, 101, 78},
		EContent:     []byte{0x61, 0x62, 0x63, 0x64}, // should be a DER-encoded TBSCertificate, but here is "abcd"
	},
	SignerInfos: SignerInfosSET{
		SignerInfo{
			Version: 3,
			SID: SignerIdentifier{
				Issuer: pkix.RDNSequence{
					pkix.RelativeDistinguishedNameSET{pkix.AttributeTypeAndValue{Type: asn1.ObjectIdentifier{2, 5, 4, 6}, Value: "GB"}},
					pkix.RelativeDistinguishedNameSET{pkix.AttributeTypeAndValue{Type: asn1.ObjectIdentifier{2, 5, 4, 8}, Value: "London"}},
					pkix.RelativeDistinguishedNameSET{pkix.AttributeTypeAndValue{Type: asn1.ObjectIdentifier{2, 5, 4, 7}, Value: "London"}},
					pkix.RelativeDistinguishedNameSET{pkix.AttributeTypeAndValue{Type: asn1.ObjectIdentifier{2, 5, 4, 10}, Value: "Google"}},
					pkix.RelativeDistinguishedNameSET{pkix.AttributeTypeAndValue{Type: asn1.ObjectIdentifier{2, 5, 4, 11}, Value: "Eng"}},
					pkix.RelativeDistinguishedNameSET{pkix.AttributeTypeAndValue{Type: asn1.ObjectIdentifier{2, 5, 4, 3}, Value: "FakeCertificateAuthority"}},
				},
				SerialNumber: big.NewInt(0x0406cafe)},
			DigestAlgorithm:    pkix.AlgorithmIdentifier{Algorithm: asn1.ObjectIdentifier{2, 16, 840, 1, 101, 3, 4, 2, 1}},
			SignatureAlgorithm: pkix.AlgorithmIdentifier{Algorithm: asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 11}},
			SignedAttributes: AttributesSET{
				Attribute{
					AttrType: cmsContentTypeOID,
					AttrValues: AttrValuesSET{
						// OID 1.3.101.78 as in EncapContentInfo.EContentType.
						asn1.RawValue{
							Class:     asn1.ClassUniversal,
							Tag:       asn1.TagOID,
							Bytes:     []byte{0x2b, 0x65, 0x4e},
							FullBytes: fullBytes(byte(asn1.TagOID), []byte{0x2b, 0x65, 0x4e}),
						},
					},
				},
				Attribute{
					AttrType: cmsMessageDigestOID,
					AttrValues: AttrValuesSET{
						asn1.RawValue{
							Class:     asn1.ClassUniversal,
							Tag:       asn1.TagOctetString,
							Bytes:     testdata.FromHex(testdata.AbcdSHA256),
							FullBytes: fullBytes(byte(asn1.TagOctetString), testdata.FromHex(testdata.AbcdSHA256)),
						},
					},
				},
			},
			Signature: []byte{0xab, 0xcd},
		},
	},
}

// Given some data, return the DER-encoded equivalent with the supplied
// tag (and assuming the class is asn1.ClassUniversal), by prefixing with
// the type/length.
func fullBytes(tag byte, data []byte) []byte {
	result := make([]byte, len(data)+2)
	result[0] = tag
	if len(data) > 255 {
		panic("len too long")
	}
	result[1] = byte(len(data))
	copy(result[2:], data)
	return result
}
