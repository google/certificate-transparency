// Code generated by protoc-gen-go.
// source: proto/ct.proto
// DO NOT EDIT!

package ct

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type LogEntryType int32

const (
	LogEntryType_X509_ENTRY       LogEntryType = 0
	LogEntryType_PRECERT_ENTRY    LogEntryType = 1
	LogEntryType_PRECERT_ENTRY_V2 LogEntryType = 2
	// Not part of the I-D, and outside the valid range.
	LogEntryType_X_JSON_ENTRY       LogEntryType = 32768
	LogEntryType_UNKNOWN_ENTRY_TYPE LogEntryType = 65536
)

var LogEntryType_name = map[int32]string{
	0:     "X509_ENTRY",
	1:     "PRECERT_ENTRY",
	2:     "PRECERT_ENTRY_V2",
	32768: "X_JSON_ENTRY",
	65536: "UNKNOWN_ENTRY_TYPE",
}
var LogEntryType_value = map[string]int32{
	"X509_ENTRY":         0,
	"PRECERT_ENTRY":      1,
	"PRECERT_ENTRY_V2":   2,
	"X_JSON_ENTRY":       32768,
	"UNKNOWN_ENTRY_TYPE": 65536,
}

func (x LogEntryType) String() string {
	return proto.EnumName(LogEntryType_name, int32(x))
}
func (LogEntryType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type SignatureType int32

const (
	SignatureType_CERTIFICATE_TIMESTAMP SignatureType = 0
	// TODO(ekasper): called tree_hash in I-D.
	SignatureType_TREE_HEAD SignatureType = 1
)

var SignatureType_name = map[int32]string{
	0: "CERTIFICATE_TIMESTAMP",
	1: "TREE_HEAD",
}
var SignatureType_value = map[string]int32{
	"CERTIFICATE_TIMESTAMP": 0,
	"TREE_HEAD":             1,
}

func (x SignatureType) String() string {
	return proto.EnumName(SignatureType_name, int32(x))
}
func (SignatureType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type Version int32

const (
	Version_V1 Version = 0
	Version_V2 Version = 1
	// Not part of the I-D, and outside the valid range.
	Version_UNKNOWN_VERSION Version = 256
)

var Version_name = map[int32]string{
	0:   "V1",
	1:   "V2",
	256: "UNKNOWN_VERSION",
}
var Version_value = map[string]int32{
	"V1":              0,
	"V2":              1,
	"UNKNOWN_VERSION": 256,
}

func (x Version) String() string {
	return proto.EnumName(Version_name, int32(x))
}
func (Version) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

type MerkleLeafType int32

const (
	MerkleLeafType_TIMESTAMPED_ENTRY MerkleLeafType = 0
	MerkleLeafType_UNKNOWN_LEAF_TYPE MerkleLeafType = 256
)

var MerkleLeafType_name = map[int32]string{
	0:   "TIMESTAMPED_ENTRY",
	256: "UNKNOWN_LEAF_TYPE",
}
var MerkleLeafType_value = map[string]int32{
	"TIMESTAMPED_ENTRY": 0,
	"UNKNOWN_LEAF_TYPE": 256,
}

func (x MerkleLeafType) String() string {
	return proto.EnumName(MerkleLeafType_name, int32(x))
}
func (MerkleLeafType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

type DigitallySigned_HashAlgorithm int32

const (
	DigitallySigned_NONE   DigitallySigned_HashAlgorithm = 0
	DigitallySigned_MD5    DigitallySigned_HashAlgorithm = 1
	DigitallySigned_SHA1   DigitallySigned_HashAlgorithm = 2
	DigitallySigned_SHA224 DigitallySigned_HashAlgorithm = 3
	DigitallySigned_SHA256 DigitallySigned_HashAlgorithm = 4
	DigitallySigned_SHA384 DigitallySigned_HashAlgorithm = 5
	DigitallySigned_SHA512 DigitallySigned_HashAlgorithm = 6
)

var DigitallySigned_HashAlgorithm_name = map[int32]string{
	0: "NONE",
	1: "MD5",
	2: "SHA1",
	3: "SHA224",
	4: "SHA256",
	5: "SHA384",
	6: "SHA512",
}
var DigitallySigned_HashAlgorithm_value = map[string]int32{
	"NONE":   0,
	"MD5":    1,
	"SHA1":   2,
	"SHA224": 3,
	"SHA256": 4,
	"SHA384": 5,
	"SHA512": 6,
}

func (x DigitallySigned_HashAlgorithm) String() string {
	return proto.EnumName(DigitallySigned_HashAlgorithm_name, int32(x))
}
func (DigitallySigned_HashAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 0}
}

type DigitallySigned_SignatureAlgorithm int32

const (
	DigitallySigned_ANONYMOUS DigitallySigned_SignatureAlgorithm = 0
	DigitallySigned_RSA       DigitallySigned_SignatureAlgorithm = 1
	DigitallySigned_DSA       DigitallySigned_SignatureAlgorithm = 2
	DigitallySigned_ECDSA     DigitallySigned_SignatureAlgorithm = 3
)

var DigitallySigned_SignatureAlgorithm_name = map[int32]string{
	0: "ANONYMOUS",
	1: "RSA",
	2: "DSA",
	3: "ECDSA",
}
var DigitallySigned_SignatureAlgorithm_value = map[string]int32{
	"ANONYMOUS": 0,
	"RSA":       1,
	"DSA":       2,
	"ECDSA":     3,
}

func (x DigitallySigned_SignatureAlgorithm) String() string {
	return proto.EnumName(DigitallySigned_SignatureAlgorithm_name, int32(x))
}
func (DigitallySigned_SignatureAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 1}
}

// RFC 5246
type DigitallySigned struct {
	// 1 byte
	HashAlgorithm DigitallySigned_HashAlgorithm `protobuf:"varint,1,opt,name=hash_algorithm,enum=ct.DigitallySigned_HashAlgorithm" json:"hash_algorithm,omitempty"`
	// 1 byte
	SigAlgorithm DigitallySigned_SignatureAlgorithm `protobuf:"varint,2,opt,name=sig_algorithm,enum=ct.DigitallySigned_SignatureAlgorithm" json:"sig_algorithm,omitempty"`
	// 0..2^16-1 bytes
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DigitallySigned) Reset()                    { *m = DigitallySigned{} }
func (m *DigitallySigned) String() string            { return proto.CompactTextString(m) }
func (*DigitallySigned) ProtoMessage()               {}
func (*DigitallySigned) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type X509ChainEntry struct {
	// For V1 this entry just includes the certificate in the leaf_certificate
	// field
	// <1..2^24-1>
	LeafCertificate []byte `protobuf:"bytes,1,opt,name=leaf_certificate,proto3" json:"leaf_certificate,omitempty"`
	// For V2 it includes the cert and key hash using CertInfo. The
	// leaf_certificate field is not used
	CertInfo *CertInfo `protobuf:"bytes,3,opt,name=cert_info" json:"cert_info,omitempty"`
	// <0..2^24-1>
	// A chain from the leaf to a trusted root
	// (excluding leaf and possibly root).
	CertificateChain [][]byte `protobuf:"bytes,2,rep,name=certificate_chain,proto3" json:"certificate_chain,omitempty"`
}

func (m *X509ChainEntry) Reset()                    { *m = X509ChainEntry{} }
func (m *X509ChainEntry) String() string            { return proto.CompactTextString(m) }
func (*X509ChainEntry) ProtoMessage()               {}
func (*X509ChainEntry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *X509ChainEntry) GetCertInfo() *CertInfo {
	if m != nil {
		return m.CertInfo
	}
	return nil
}

// opaque TBSCertificate<1..2^16-1>;
// struct {
//   opaque issuer_key_hash[32];
//   TBSCertificate tbs_certificate;
// } PreCert;
// Retained for V1 API compatibility. May be removed in a future release.
type PreCert struct {
	IssuerKeyHash  []byte `protobuf:"bytes,1,opt,name=issuer_key_hash,proto3" json:"issuer_key_hash,omitempty"`
	TbsCertificate []byte `protobuf:"bytes,2,opt,name=tbs_certificate,proto3" json:"tbs_certificate,omitempty"`
}

func (m *PreCert) Reset()                    { *m = PreCert{} }
func (m *PreCert) String() string            { return proto.CompactTextString(m) }
func (*PreCert) ProtoMessage()               {}
func (*PreCert) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

// In V2 this is used for both certificates and precertificates in SCTs. It
// replaces PreCert and has the same structure. The older message remains for
// compatibility with existing code that depends on this proto.
type CertInfo struct {
	IssuerKeyHash  []byte `protobuf:"bytes,1,opt,name=issuer_key_hash,proto3" json:"issuer_key_hash,omitempty"`
	TbsCertificate []byte `protobuf:"bytes,2,opt,name=tbs_certificate,proto3" json:"tbs_certificate,omitempty"`
}

func (m *CertInfo) Reset()                    { *m = CertInfo{} }
func (m *CertInfo) String() string            { return proto.CompactTextString(m) }
func (*CertInfo) ProtoMessage()               {}
func (*CertInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

type PrecertChainEntry struct {
	// <1..2^24-1>
	PreCertificate []byte `protobuf:"bytes,1,opt,name=pre_certificate,proto3" json:"pre_certificate,omitempty"`
	// <0..2^24-1>
	// The chain certifying the precertificate, as submitted by the CA.
	PrecertificateChain [][]byte `protobuf:"bytes,2,rep,name=precertificate_chain,proto3" json:"precertificate_chain,omitempty"`
	// PreCert input to the SCT. Can be computed from the above.
	// Store it alongside the entry data so that the signers don't have to
	// parse certificates to recompute it.
	PreCert *PreCert `protobuf:"bytes,3,opt,name=pre_cert" json:"pre_cert,omitempty"`
	// As above for V2 messages. Only one of these fields will be set in a
	// valid message
	CertInfo *CertInfo `protobuf:"bytes,4,opt,name=cert_info" json:"cert_info,omitempty"`
}

func (m *PrecertChainEntry) Reset()                    { *m = PrecertChainEntry{} }
func (m *PrecertChainEntry) String() string            { return proto.CompactTextString(m) }
func (*PrecertChainEntry) ProtoMessage()               {}
func (*PrecertChainEntry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *PrecertChainEntry) GetPreCert() *PreCert {
	if m != nil {
		return m.PreCert
	}
	return nil
}

func (m *PrecertChainEntry) GetCertInfo() *CertInfo {
	if m != nil {
		return m.CertInfo
	}
	return nil
}

type XJSONEntry struct {
	Json string `protobuf:"bytes,1,opt,name=json" json:"json,omitempty"`
}

func (m *XJSONEntry) Reset()                    { *m = XJSONEntry{} }
func (m *XJSONEntry) String() string            { return proto.CompactTextString(m) }
func (*XJSONEntry) ProtoMessage()               {}
func (*XJSONEntry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

// TODO(alcutter): Consider using extensions here instead.
type LogEntry struct {
	Type         LogEntryType       `protobuf:"varint,1,opt,name=type,enum=ct.LogEntryType" json:"type,omitempty"`
	X509Entry    *X509ChainEntry    `protobuf:"bytes,2,opt,name=x509_entry" json:"x509_entry,omitempty"`
	PrecertEntry *PrecertChainEntry `protobuf:"bytes,3,opt,name=precert_entry" json:"precert_entry,omitempty"`
	XJsonEntry   *XJSONEntry        `protobuf:"bytes,4,opt,name=x_json_entry" json:"x_json_entry,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *LogEntry) GetX509Entry() *X509ChainEntry {
	if m != nil {
		return m.X509Entry
	}
	return nil
}

func (m *LogEntry) GetPrecertEntry() *PrecertChainEntry {
	if m != nil {
		return m.PrecertEntry
	}
	return nil
}

func (m *LogEntry) GetXJsonEntry() *XJSONEntry {
	if m != nil {
		return m.XJsonEntry
	}
	return nil
}

type LogID struct {
	// 32 bytes
	KeyId []byte `protobuf:"bytes,1,opt,name=key_id,proto3" json:"key_id,omitempty"`
}

func (m *LogID) Reset()                    { *m = LogID{} }
func (m *LogID) String() string            { return proto.CompactTextString(m) }
func (*LogID) ProtoMessage()               {}
func (*LogID) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

type SctExtension struct {
	// Valid range is 0-65534
	SctExtensionType uint32 `protobuf:"varint,1,opt,name=sct_extension_type" json:"sct_extension_type,omitempty"`
	// Data is opaque and type specific. <0..2^16-1> bytes
	SctExtensionData []byte `protobuf:"bytes,2,opt,name=sct_extension_data,proto3" json:"sct_extension_data,omitempty"`
}

func (m *SctExtension) Reset()                    { *m = SctExtension{} }
func (m *SctExtension) String() string            { return proto.CompactTextString(m) }
func (*SctExtension) ProtoMessage()               {}
func (*SctExtension) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

// TODO(ekasper): implement support for id.
type SignedCertificateTimestamp struct {
	Version Version `protobuf:"varint,1,opt,name=version,enum=ct.Version" json:"version,omitempty"`
	Id      *LogID  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// UTC time in milliseconds, since January 1, 1970, 00:00.
	Timestamp uint64           `protobuf:"varint,3,opt,name=timestamp" json:"timestamp,omitempty"`
	Signature *DigitallySigned `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	// V1 extensions
	Extensions []byte `protobuf:"bytes,5,opt,name=extensions,proto3" json:"extensions,omitempty"`
	// V2 extensions <0..2^16-1>. Must be ordered by type (lowest first)
	SctExtension []*SctExtension `protobuf:"bytes,6,rep,name=sct_extension" json:"sct_extension,omitempty"`
}

func (m *SignedCertificateTimestamp) Reset()                    { *m = SignedCertificateTimestamp{} }
func (m *SignedCertificateTimestamp) String() string            { return proto.CompactTextString(m) }
func (*SignedCertificateTimestamp) ProtoMessage()               {}
func (*SignedCertificateTimestamp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *SignedCertificateTimestamp) GetId() *LogID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SignedCertificateTimestamp) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedCertificateTimestamp) GetSctExtension() []*SctExtension {
	if m != nil {
		return m.SctExtension
	}
	return nil
}

type SignedCertificateTimestampList struct {
	// One or more SCTs, <1..2^16-1> bytes each
	SctList [][]byte `protobuf:"bytes,1,rep,name=sct_list,proto3" json:"sct_list,omitempty"`
}

func (m *SignedCertificateTimestampList) Reset()                    { *m = SignedCertificateTimestampList{} }
func (m *SignedCertificateTimestampList) String() string            { return proto.CompactTextString(m) }
func (*SignedCertificateTimestampList) ProtoMessage()               {}
func (*SignedCertificateTimestampList) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

type SignedEntry struct {
	// For V1 signed entries either the x509 or precert field will be set
	X509    []byte   `protobuf:"bytes,1,opt,name=x509,proto3" json:"x509,omitempty"`
	Precert *PreCert `protobuf:"bytes,2,opt,name=precert" json:"precert,omitempty"`
	Json    []byte   `protobuf:"bytes,3,opt,name=json,proto3" json:"json,omitempty"`
	// For V2 all entries use the CertInfo field and the above fields are
	// not set
	CertInfo *CertInfo `protobuf:"bytes,4,opt,name=cert_info" json:"cert_info,omitempty"`
}

func (m *SignedEntry) Reset()                    { *m = SignedEntry{} }
func (m *SignedEntry) String() string            { return proto.CompactTextString(m) }
func (*SignedEntry) ProtoMessage()               {}
func (*SignedEntry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func (m *SignedEntry) GetPrecert() *PreCert {
	if m != nil {
		return m.Precert
	}
	return nil
}

func (m *SignedEntry) GetCertInfo() *CertInfo {
	if m != nil {
		return m.CertInfo
	}
	return nil
}

type TimestampedEntry struct {
	Timestamp   uint64       `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	EntryType   LogEntryType `protobuf:"varint,2,opt,name=entry_type,enum=ct.LogEntryType" json:"entry_type,omitempty"`
	SignedEntry *SignedEntry `protobuf:"bytes,3,opt,name=signed_entry" json:"signed_entry,omitempty"`
	// V1 extensions
	Extensions []byte `protobuf:"bytes,4,opt,name=extensions,proto3" json:"extensions,omitempty"`
	// V2 extensions <0..2^16-1>. Must be ordered by type (lowest first)
	SctExtension []*SctExtension `protobuf:"bytes,5,rep,name=sct_extension" json:"sct_extension,omitempty"`
}

func (m *TimestampedEntry) Reset()                    { *m = TimestampedEntry{} }
func (m *TimestampedEntry) String() string            { return proto.CompactTextString(m) }
func (*TimestampedEntry) ProtoMessage()               {}
func (*TimestampedEntry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{12} }

func (m *TimestampedEntry) GetSignedEntry() *SignedEntry {
	if m != nil {
		return m.SignedEntry
	}
	return nil
}

func (m *TimestampedEntry) GetSctExtension() []*SctExtension {
	if m != nil {
		return m.SctExtension
	}
	return nil
}

// Stuff that's hashed into a Merkle leaf.
type MerkleTreeLeaf struct {
	// The version of the corresponding SCT.
	Version          Version           `protobuf:"varint,1,opt,name=version,enum=ct.Version" json:"version,omitempty"`
	Type             MerkleLeafType    `protobuf:"varint,2,opt,name=type,enum=ct.MerkleLeafType" json:"type,omitempty"`
	TimestampedEntry *TimestampedEntry `protobuf:"bytes,3,opt,name=timestamped_entry" json:"timestamped_entry,omitempty"`
}

func (m *MerkleTreeLeaf) Reset()                    { *m = MerkleTreeLeaf{} }
func (m *MerkleTreeLeaf) String() string            { return proto.CompactTextString(m) }
func (*MerkleTreeLeaf) ProtoMessage()               {}
func (*MerkleTreeLeaf) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{13} }

func (m *MerkleTreeLeaf) GetTimestampedEntry() *TimestampedEntry {
	if m != nil {
		return m.TimestampedEntry
	}
	return nil
}

// TODO(benl): No longer needed?
//
// Used by cpp/client/ct: it assembles the one from the I-D JSON
// protocol.
//
// Used by cpp/server/blob-server: it uses one to call a variant of
// LogLookup::AuditProof.
type MerkleAuditProof struct {
	Version           Version          `protobuf:"varint,1,opt,name=version,enum=ct.Version" json:"version,omitempty"`
	Id                *LogID           `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	TreeSize          int64            `protobuf:"varint,3,opt,name=tree_size" json:"tree_size,omitempty"`
	Timestamp         uint64           `protobuf:"varint,4,opt,name=timestamp" json:"timestamp,omitempty"`
	LeafIndex         int64            `protobuf:"varint,5,opt,name=leaf_index" json:"leaf_index,omitempty"`
	PathNode          [][]byte         `protobuf:"bytes,6,rep,name=path_node,proto3" json:"path_node,omitempty"`
	TreeHeadSignature *DigitallySigned `protobuf:"bytes,7,opt,name=tree_head_signature" json:"tree_head_signature,omitempty"`
}

func (m *MerkleAuditProof) Reset()                    { *m = MerkleAuditProof{} }
func (m *MerkleAuditProof) String() string            { return proto.CompactTextString(m) }
func (*MerkleAuditProof) ProtoMessage()               {}
func (*MerkleAuditProof) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{14} }

func (m *MerkleAuditProof) GetId() *LogID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MerkleAuditProof) GetTreeHeadSignature() *DigitallySigned {
	if m != nil {
		return m.TreeHeadSignature
	}
	return nil
}

type ShortMerkleAuditProof struct {
	LeafIndex int64  `protobuf:"varint,1,opt,name=leaf_index" json:"leaf_index,omitempty"`
	PathNode  []byte `protobuf:"bytes,2,opt,name=path_node,proto3" json:"path_node,omitempty"`
}

func (m *ShortMerkleAuditProof) Reset()                    { *m = ShortMerkleAuditProof{} }
func (m *ShortMerkleAuditProof) String() string            { return proto.CompactTextString(m) }
func (*ShortMerkleAuditProof) ProtoMessage()               {}
func (*ShortMerkleAuditProof) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{15} }

// TODO(alcutter): Come up with a better name :/
type LoggedEntryPB struct {
	SequenceNumber int64                   `protobuf:"varint,1,opt,name=sequence_number" json:"sequence_number,omitempty"`
	MerkleLeafHash []byte                  `protobuf:"bytes,2,opt,name=merkle_leaf_hash,proto3" json:"merkle_leaf_hash,omitempty"`
	Contents       *LoggedEntryPB_Contents `protobuf:"bytes,3,opt,name=contents" json:"contents,omitempty"`
}

func (m *LoggedEntryPB) Reset()                    { *m = LoggedEntryPB{} }
func (m *LoggedEntryPB) String() string            { return proto.CompactTextString(m) }
func (*LoggedEntryPB) ProtoMessage()               {}
func (*LoggedEntryPB) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{16} }

func (m *LoggedEntryPB) GetContents() *LoggedEntryPB_Contents {
	if m != nil {
		return m.Contents
	}
	return nil
}

type LoggedEntryPB_Contents struct {
	Sct   *SignedCertificateTimestamp `protobuf:"bytes,1,opt,name=sct" json:"sct,omitempty"`
	Entry *LogEntry                   `protobuf:"bytes,2,opt,name=entry" json:"entry,omitempty"`
}

func (m *LoggedEntryPB_Contents) Reset()                    { *m = LoggedEntryPB_Contents{} }
func (m *LoggedEntryPB_Contents) String() string            { return proto.CompactTextString(m) }
func (*LoggedEntryPB_Contents) ProtoMessage()               {}
func (*LoggedEntryPB_Contents) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{16, 0} }

func (m *LoggedEntryPB_Contents) GetSct() *SignedCertificateTimestamp {
	if m != nil {
		return m.Sct
	}
	return nil
}

func (m *LoggedEntryPB_Contents) GetEntry() *LogEntry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type SthExtension struct {
	// Valid range is 0-65534
	SthExtensionType uint32 `protobuf:"varint,1,opt,name=sth_extension_type" json:"sth_extension_type,omitempty"`
	// Data is opaque and type specific <0..2^16-1> bytes
	SthExtensionData []byte `protobuf:"bytes,2,opt,name=sth_extension_data,proto3" json:"sth_extension_data,omitempty"`
}

func (m *SthExtension) Reset()                    { *m = SthExtension{} }
func (m *SthExtension) String() string            { return proto.CompactTextString(m) }
func (*SthExtension) ProtoMessage()               {}
func (*SthExtension) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{17} }

type SignedTreeHead struct {
	// The version of the tree head signature.
	// (Note that each leaf has its own version, so a V2 tree
	// can contain V1 leaves, too.
	Version        Version          `protobuf:"varint,1,opt,name=version,enum=ct.Version" json:"version,omitempty"`
	Id             *LogID           `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Timestamp      uint64           `protobuf:"varint,3,opt,name=timestamp" json:"timestamp,omitempty"`
	TreeSize       int64            `protobuf:"varint,4,opt,name=tree_size" json:"tree_size,omitempty"`
	Sha256RootHash []byte           `protobuf:"bytes,5,opt,name=sha256_root_hash,proto3" json:"sha256_root_hash,omitempty"`
	Signature      *DigitallySigned `protobuf:"bytes,6,opt,name=signature" json:"signature,omitempty"`
	// Only supported in V2. <0..2^16-1>
	SthExtension []*SthExtension `protobuf:"bytes,7,rep,name=sth_extension" json:"sth_extension,omitempty"`
}

func (m *SignedTreeHead) Reset()                    { *m = SignedTreeHead{} }
func (m *SignedTreeHead) String() string            { return proto.CompactTextString(m) }
func (*SignedTreeHead) ProtoMessage()               {}
func (*SignedTreeHead) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{18} }

func (m *SignedTreeHead) GetId() *LogID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SignedTreeHead) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedTreeHead) GetSthExtension() []*SthExtension {
	if m != nil {
		return m.SthExtension
	}
	return nil
}

// Stuff the SSL client spits out from a connection.
type SSLClientCTData struct {
	ReconstructedEntry    *LogEntry                  `protobuf:"bytes,1,opt,name=reconstructed_entry" json:"reconstructed_entry,omitempty"`
	CertificateSha256Hash []byte                     `protobuf:"bytes,2,opt,name=certificate_sha256_hash,proto3" json:"certificate_sha256_hash,omitempty"`
	AttachedSctInfo       []*SSLClientCTData_SCTInfo `protobuf:"bytes,3,rep,name=attached_sct_info" json:"attached_sct_info,omitempty"`
}

func (m *SSLClientCTData) Reset()                    { *m = SSLClientCTData{} }
func (m *SSLClientCTData) String() string            { return proto.CompactTextString(m) }
func (*SSLClientCTData) ProtoMessage()               {}
func (*SSLClientCTData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{19} }

func (m *SSLClientCTData) GetReconstructedEntry() *LogEntry {
	if m != nil {
		return m.ReconstructedEntry
	}
	return nil
}

func (m *SSLClientCTData) GetAttachedSctInfo() []*SSLClientCTData_SCTInfo {
	if m != nil {
		return m.AttachedSctInfo
	}
	return nil
}

type SSLClientCTData_SCTInfo struct {
	// There is an entry + sct -> leaf hash mapping.
	Sct            *SignedCertificateTimestamp `protobuf:"bytes,1,opt,name=sct" json:"sct,omitempty"`
	MerkleLeafHash []byte                      `protobuf:"bytes,2,opt,name=merkle_leaf_hash,proto3" json:"merkle_leaf_hash,omitempty"`
}

func (m *SSLClientCTData_SCTInfo) Reset()                    { *m = SSLClientCTData_SCTInfo{} }
func (m *SSLClientCTData_SCTInfo) String() string            { return proto.CompactTextString(m) }
func (*SSLClientCTData_SCTInfo) ProtoMessage()               {}
func (*SSLClientCTData_SCTInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{19, 0} }

func (m *SSLClientCTData_SCTInfo) GetSct() *SignedCertificateTimestamp {
	if m != nil {
		return m.Sct
	}
	return nil
}

type ClusterNodeState struct {
	NodeId             string          `protobuf:"bytes,1,opt,name=node_id" json:"node_id,omitempty"`
	ContiguousTreeSize int64           `protobuf:"varint,2,opt,name=contiguous_tree_size" json:"contiguous_tree_size,omitempty"`
	NewestSth          *SignedTreeHead `protobuf:"bytes,3,opt,name=newest_sth" json:"newest_sth,omitempty"`
	CurrentServingSth  *SignedTreeHead `protobuf:"bytes,4,opt,name=current_serving_sth" json:"current_serving_sth,omitempty"`
	// The following host_name/log_port pair are used to allow a log node to
	// contact other nodes in the cluster, primarily for the purposes of
	// replication.
	// hostname/ip which can be used to contact [just] this log node
	Hostname string `protobuf:"bytes,5,opt,name=hostname" json:"hostname,omitempty"`
	// port on which this log node is listening.
	LogPort int32 `protobuf:"varint,6,opt,name=log_port" json:"log_port,omitempty"`
}

func (m *ClusterNodeState) Reset()                    { *m = ClusterNodeState{} }
func (m *ClusterNodeState) String() string            { return proto.CompactTextString(m) }
func (*ClusterNodeState) ProtoMessage()               {}
func (*ClusterNodeState) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{20} }

func (m *ClusterNodeState) GetNewestSth() *SignedTreeHead {
	if m != nil {
		return m.NewestSth
	}
	return nil
}

func (m *ClusterNodeState) GetCurrentServingSth() *SignedTreeHead {
	if m != nil {
		return m.CurrentServingSth
	}
	return nil
}

type ClusterControl struct {
	AcceptNewEntries bool `protobuf:"varint,1,opt,name=accept_new_entries" json:"accept_new_entries,omitempty"`
}

func (m *ClusterControl) Reset()                    { *m = ClusterControl{} }
func (m *ClusterControl) String() string            { return proto.CompactTextString(m) }
func (*ClusterControl) ProtoMessage()               {}
func (*ClusterControl) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{21} }

type ClusterConfig struct {
	// The minimum number of nodes which must be able to serve a given STH.
	// This setting allows you to configure the level of cluster resiliency
	// against data (in the form of node/node database) loss.
	// i.e.: Once an STH has been created, it must have been replicated to
	// at least this many nodes before being considered as a candidate for
	// the overall cluster serving STH.
	MinimumServingNodes int32 `protobuf:"varint,1,opt,name=minimum_serving_nodes" json:"minimum_serving_nodes,omitempty"`
	// The minimum fraction of nodes which must be able to serve a given STH.
	// This setting allows you to configure the serving capacity redundancy of
	// your cluster.
	// e.g. you determine you need 3 nodes to serve your expected peak traffic
	// levels, but want to be over-provisioned by 25% to ensure the cluster will
	// continue to be able to handle the traffic in the case of a single node
	// failure, you might set this to 0.75 to ensure that any cluster-wide
	// serving STH candidate must be servable from at least 3 of your 4 nodes.
	MinimumServingFraction float64 `protobuf:"fixed64,2,opt,name=minimum_serving_fraction" json:"minimum_serving_fraction,omitempty"`
	// When the number of entries in the EtcedConsistentStore exceeds this value,
	// the log server will reject all calls to add-[pre-]chain to protect itself
	// and etcd.
	EtcdRejectAddPendingThreshold float64 `protobuf:"fixed64,3,opt,name=etcd_reject_add_pending_threshold" json:"etcd_reject_add_pending_threshold,omitempty"`
}

func (m *ClusterConfig) Reset()                    { *m = ClusterConfig{} }
func (m *ClusterConfig) String() string            { return proto.CompactTextString(m) }
func (*ClusterConfig) ProtoMessage()               {}
func (*ClusterConfig) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{22} }

type SequenceMapping struct {
	Mapping []*SequenceMapping_Mapping `protobuf:"bytes,1,rep,name=mapping" json:"mapping,omitempty"`
}

func (m *SequenceMapping) Reset()                    { *m = SequenceMapping{} }
func (m *SequenceMapping) String() string            { return proto.CompactTextString(m) }
func (*SequenceMapping) ProtoMessage()               {}
func (*SequenceMapping) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{23} }

func (m *SequenceMapping) GetMapping() []*SequenceMapping_Mapping {
	if m != nil {
		return m.Mapping
	}
	return nil
}

type SequenceMapping_Mapping struct {
	EntryHash      []byte `protobuf:"bytes,1,opt,name=entry_hash,proto3" json:"entry_hash,omitempty"`
	SequenceNumber int64  `protobuf:"varint,2,opt,name=sequence_number" json:"sequence_number,omitempty"`
}

func (m *SequenceMapping_Mapping) Reset()                    { *m = SequenceMapping_Mapping{} }
func (m *SequenceMapping_Mapping) String() string            { return proto.CompactTextString(m) }
func (*SequenceMapping_Mapping) ProtoMessage()               {}
func (*SequenceMapping_Mapping) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{23, 0} }

func init() {
	proto.RegisterType((*DigitallySigned)(nil), "ct.DigitallySigned")
	proto.RegisterType((*X509ChainEntry)(nil), "ct.X509ChainEntry")
	proto.RegisterType((*PreCert)(nil), "ct.PreCert")
	proto.RegisterType((*CertInfo)(nil), "ct.CertInfo")
	proto.RegisterType((*PrecertChainEntry)(nil), "ct.PrecertChainEntry")
	proto.RegisterType((*XJSONEntry)(nil), "ct.XJSONEntry")
	proto.RegisterType((*LogEntry)(nil), "ct.LogEntry")
	proto.RegisterType((*LogID)(nil), "ct.LogID")
	proto.RegisterType((*SctExtension)(nil), "ct.SctExtension")
	proto.RegisterType((*SignedCertificateTimestamp)(nil), "ct.SignedCertificateTimestamp")
	proto.RegisterType((*SignedCertificateTimestampList)(nil), "ct.SignedCertificateTimestampList")
	proto.RegisterType((*SignedEntry)(nil), "ct.SignedEntry")
	proto.RegisterType((*TimestampedEntry)(nil), "ct.TimestampedEntry")
	proto.RegisterType((*MerkleTreeLeaf)(nil), "ct.MerkleTreeLeaf")
	proto.RegisterType((*MerkleAuditProof)(nil), "ct.MerkleAuditProof")
	proto.RegisterType((*ShortMerkleAuditProof)(nil), "ct.ShortMerkleAuditProof")
	proto.RegisterType((*LoggedEntryPB)(nil), "ct.LoggedEntryPB")
	proto.RegisterType((*LoggedEntryPB_Contents)(nil), "ct.LoggedEntryPB.Contents")
	proto.RegisterType((*SthExtension)(nil), "ct.SthExtension")
	proto.RegisterType((*SignedTreeHead)(nil), "ct.SignedTreeHead")
	proto.RegisterType((*SSLClientCTData)(nil), "ct.SSLClientCTData")
	proto.RegisterType((*SSLClientCTData_SCTInfo)(nil), "ct.SSLClientCTData.SCTInfo")
	proto.RegisterType((*ClusterNodeState)(nil), "ct.ClusterNodeState")
	proto.RegisterType((*ClusterControl)(nil), "ct.ClusterControl")
	proto.RegisterType((*ClusterConfig)(nil), "ct.ClusterConfig")
	proto.RegisterType((*SequenceMapping)(nil), "ct.SequenceMapping")
	proto.RegisterType((*SequenceMapping_Mapping)(nil), "ct.SequenceMapping.Mapping")
	proto.RegisterEnum("ct.LogEntryType", LogEntryType_name, LogEntryType_value)
	proto.RegisterEnum("ct.SignatureType", SignatureType_name, SignatureType_value)
	proto.RegisterEnum("ct.Version", Version_name, Version_value)
	proto.RegisterEnum("ct.MerkleLeafType", MerkleLeafType_name, MerkleLeafType_value)
	proto.RegisterEnum("ct.DigitallySigned_HashAlgorithm", DigitallySigned_HashAlgorithm_name, DigitallySigned_HashAlgorithm_value)
	proto.RegisterEnum("ct.DigitallySigned_SignatureAlgorithm", DigitallySigned_SignatureAlgorithm_name, DigitallySigned_SignatureAlgorithm_value)
}

var fileDescriptor1 = []byte{
	// 1482 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x57, 0xdd, 0x72, 0xdb, 0x44,
	0x14, 0x46, 0xfe, 0x89, 0xe3, 0x13, 0xdb, 0x91, 0x37, 0x09, 0x4d, 0x5d, 0x28, 0xad, 0xa6, 0x14,
	0x08, 0x9d, 0xa4, 0x75, 0x9b, 0x0e, 0x1d, 0x7e, 0x5d, 0x5b, 0x9d, 0x04, 0x12, 0xc7, 0x13, 0xbb,
	0xa1, 0x9d, 0x61, 0x46, 0xa3, 0xca, 0x6b, 0x4b, 0xad, 0x2d, 0x19, 0x69, 0xdd, 0x26, 0x70, 0x53,
	0x6e, 0x79, 0x10, 0x6e, 0x79, 0x03, 0x2e, 0xb8, 0x60, 0x86, 0x17, 0xe0, 0x15, 0x78, 0x0d, 0xce,
	0xae, 0x56, 0xb2, 0x94, 0xd8, 0xc3, 0x94, 0xe1, 0xca, 0x3b, 0x47, 0xe7, 0xf7, 0x3b, 0xdf, 0x39,
	0xbb, 0x86, 0xca, 0xc4, 0xf7, 0x98, 0xb7, 0x63, 0xb1, 0x6d, 0x71, 0x20, 0x19, 0x8b, 0x69, 0xbf,
	0x65, 0x60, 0xb5, 0xe5, 0x0c, 0x1d, 0x66, 0x8e, 0x46, 0x67, 0x5d, 0x67, 0xe8, 0xd2, 0x3e, 0x79,
	0x00, 0x15, 0xdb, 0x0c, 0x6c, 0xc3, 0x1c, 0x0d, 0x3d, 0xdf, 0x61, 0xf6, 0x78, 0x53, 0xb9, 0xa6,
	0x7c, 0x58, 0xa9, 0x5f, 0xdf, 0x46, 0xd3, 0x73, 0xca, 0xdb, 0x7b, 0xa8, 0xd9, 0x88, 0x14, 0xc9,
	0xe7, 0x50, 0x0e, 0x9c, 0x61, 0xc2, 0x32, 0x23, 0x2c, 0x6f, 0xce, 0xb3, 0xe4, 0x3f, 0x26, 0x9b,
	0xfa, 0x74, 0x66, 0x5e, 0x85, 0x62, 0x10, 0x49, 0x37, 0xb3, 0x68, 0x5a, 0xd2, 0xbe, 0x83, 0x72,
	0x3a, 0xc4, 0x32, 0xe4, 0xda, 0x47, 0x6d, 0x5d, 0x7d, 0x8b, 0x14, 0x20, 0x7b, 0xd8, 0xda, 0x55,
	0x15, 0x2e, 0xea, 0xee, 0x35, 0xee, 0xa8, 0x19, 0x02, 0xb0, 0x84, 0xa7, 0x7a, 0xfd, 0x9e, 0x9a,
	0x8d, 0xce, 0xbb, 0xf7, 0xd5, 0x9c, 0x3c, 0xdf, 0xfd, 0xe4, 0x9e, 0x9a, 0x97, 0xe7, 0xdd, 0x3b,
	0x75, 0x75, 0x49, 0xfb, 0x0a, 0xc8, 0x9c, 0x34, 0xca, 0x50, 0x6c, 0x60, 0x8c, 0xa7, 0x87, 0x47,
	0x8f, 0xbb, 0x61, 0x9c, 0xe3, 0x6e, 0x03, 0xe3, 0xe0, 0xa1, 0x85, 0x87, 0x0c, 0x29, 0x42, 0x5e,
	0x6f, 0xf2, 0x63, 0x56, 0x1b, 0x40, 0xe5, 0xc9, 0xee, 0xed, 0x07, 0x4d, 0xdb, 0x74, 0x5c, 0xdd,
	0x65, 0xfe, 0x19, 0xd9, 0x04, 0x75, 0x44, 0xcd, 0x81, 0x61, 0x51, 0x9f, 0x39, 0x03, 0xc7, 0x32,
	0x19, 0x15, 0x00, 0x96, 0xc8, 0x7b, 0x50, 0xe4, 0x42, 0xc3, 0x71, 0x07, 0x9e, 0x28, 0x6f, 0xa5,
	0x5e, 0xe2, 0xc8, 0x34, 0x51, 0xb8, 0x8f, 0x32, 0x72, 0x19, 0xaa, 0x09, 0x2b, 0xc3, 0xe2, 0x4e,
	0x11, 0xc2, 0x2c, 0xe2, 0xf0, 0x29, 0x14, 0x3a, 0x3e, 0xe5, 0x9a, 0xe4, 0x12, 0xac, 0x3a, 0x41,
	0x30, 0xa5, 0xbe, 0xf1, 0x82, 0x9e, 0x19, 0xbc, 0x55, 0xd2, 0x3f, 0x7e, 0x60, 0xcf, 0x82, 0x54,
	0xe0, 0x8c, 0x00, 0xf1, 0x33, 0x58, 0x8e, 0x63, 0xbc, 0xb9, 0xf5, 0xcf, 0x0a, 0x54, 0x31, 0x36,
	0xff, 0x90, 0x28, 0x13, 0xd5, 0x27, 0x3e, 0x9d, 0x53, 0xe5, 0x3b, 0xb0, 0x3e, 0x09, 0xb5, 0xe7,
	0xd4, 0x41, 0xde, 0x85, 0xe5, 0xc8, 0x4c, 0x42, 0xb0, 0xc2, 0x21, 0x88, 0x6a, 0x4b, 0x41, 0x94,
	0xbb, 0x08, 0x91, 0x56, 0x03, 0x78, 0xf2, 0x75, 0x17, 0x09, 0x20, 0x92, 0x28, 0x41, 0xee, 0x79,
	0xe0, 0xb9, 0x22, 0x72, 0x51, 0xfb, 0x45, 0x81, 0xe5, 0x03, 0x6f, 0x18, 0x7e, 0xba, 0x0a, 0x39,
	0x76, 0x36, 0xa1, 0x92, 0xbb, 0x2a, 0x77, 0x12, 0x7d, 0xeb, 0xa1, 0x9c, 0xdc, 0x04, 0x38, 0xc5,
	0xc6, 0x19, 0x94, 0x4b, 0x44, 0xa5, 0x2b, 0x75, 0xc2, 0xb5, 0xce, 0xb5, 0xf3, 0x16, 0x94, 0x65,
	0x39, 0x52, 0x35, 0xcc, 0x7a, 0x43, 0x66, 0x7d, 0x0e, 0x95, 0x1b, 0x50, 0x3a, 0x35, 0x78, 0x4a,
	0x52, 0x39, 0x2c, 0xa1, 0x22, 0xfc, 0xc6, 0x69, 0x6b, 0x97, 0x20, 0x8f, 0xb9, 0xec, 0xb7, 0x48,
	0x05, 0x96, 0x78, 0x17, 0x9c, 0x7e, 0x88, 0x9d, 0xf6, 0x08, 0x4a, 0x5d, 0x8b, 0xe9, 0xa7, 0x8c,
	0xba, 0x81, 0xe3, 0xb9, 0xa4, 0x06, 0x24, 0xb0, 0x30, 0x70, 0x24, 0x30, 0xe2, 0x92, 0xca, 0x17,
	0xbf, 0xf5, 0x4d, 0x66, 0xca, 0x96, 0xfd, 0xa9, 0x40, 0x2d, 0x1c, 0xb3, 0xe6, 0xac, 0x0f, 0x3d,
	0x67, 0x4c, 0x03, 0x66, 0x8e, 0x27, 0xd8, 0xa2, 0xc2, 0x4b, 0xea, 0x73, 0x23, 0x09, 0x8f, 0xe8,
	0xc1, 0x49, 0x28, 0x22, 0x1b, 0x90, 0xc1, 0x84, 0x42, 0x44, 0x8a, 0x12, 0x37, 0xcc, 0x15, 0x87,
	0x93, 0x45, 0x1e, 0x04, 0x08, 0x39, 0xc4, 0x30, 0x31, 0xaf, 0x61, 0xa9, 0x6b, 0x73, 0x46, 0x9d,
	0xe0, 0xcc, 0xc5, 0x69, 0x06, 0x9b, 0x79, 0x41, 0x93, 0x0f, 0x70, 0x55, 0x24, 0xd3, 0xdf, 0x5c,
	0x42, 0x7e, 0xac, 0x84, 0x8d, 0x4a, 0x62, 0xa0, 0xd5, 0xe1, 0xea, 0xe2, 0x52, 0x0e, 0x9c, 0x80,
	0x11, 0x15, 0x96, 0xb9, 0xab, 0x11, 0x9e, 0xb1, 0x1e, 0x3e, 0x2d, 0x36, 0xac, 0x84, 0x36, 0x31,
	0x4d, 0x78, 0xaf, 0x63, 0x82, 0x16, 0x64, 0x47, 0x65, 0x91, 0x29, 0x06, 0x46, 0x94, 0xca, 0x5e,
	0x1c, 0xd9, 0x79, 0x7c, 0xfc, 0x55, 0x01, 0x35, 0xce, 0x26, 0x8a, 0x97, 0x82, 0x4a, 0x11, 0x50,
	0xdd, 0x40, 0x08, 0xf8, 0xb7, 0xb0, 0x83, 0x99, 0x05, 0xa4, 0x7c, 0x1f, 0x4a, 0x81, 0xc8, 0x3b,
	0xc5, 0xb5, 0x55, 0x81, 0x49, 0xa2, 0x9e, 0x34, 0x9e, 0xb9, 0xf9, 0x78, 0xe6, 0x17, 0xe0, 0xf9,
	0x93, 0x02, 0x95, 0x43, 0xea, 0xbf, 0x18, 0xd1, 0x9e, 0x4f, 0xe9, 0x01, 0xae, 0xaa, 0x7f, 0xe1,
	0xc3, 0x35, 0x39, 0x49, 0x61, 0xd2, 0x62, 0x46, 0x42, 0x7b, 0x6e, 0x2b, 0xd2, 0xde, 0x81, 0x2a,
	0x9b, 0x61, 0x90, 0xca, 0x7d, 0x9d, 0xab, 0x9f, 0x07, 0x48, 0xfb, 0x03, 0x51, 0x0b, 0x7d, 0x34,
	0xa6, 0x7d, 0x87, 0x75, 0x7c, 0xcf, 0x1b, 0xfc, 0x77, 0x56, 0x62, 0x19, 0x46, 0xe0, 0xfc, 0x10,
	0x5e, 0x19, 0xd9, 0x34, 0xfa, 0x39, 0x81, 0x3e, 0x02, 0x26, 0x76, 0xb2, 0xe3, 0xf6, 0xe9, 0xa9,
	0x20, 0xa0, 0x50, 0x9b, 0x98, 0xcc, 0x36, 0x5c, 0xaf, 0x4f, 0x05, 0xf9, 0x4a, 0xe4, 0x36, 0xac,
	0x09, 0x67, 0x36, 0x35, 0xfb, 0xc6, 0x8c, 0xd9, 0x85, 0x85, 0xcc, 0xd6, 0xbe, 0x80, 0x8d, 0xae,
	0xed, 0xf9, 0xec, 0x42, 0x31, 0xe9, 0x88, 0xca, 0xc5, 0x88, 0xe1, 0xa0, 0x22, 0x10, 0x65, 0x2c,
	0x64, 0x28, 0x81, 0xe9, 0x3c, 0xe4, 0x7b, 0x35, 0xa0, 0xdf, 0x4f, 0xa9, 0x6b, 0x51, 0xc3, 0x9d,
	0x8e, 0x9f, 0x51, 0x5f, 0x5a, 0xe3, 0xbd, 0x32, 0x16, 0x51, 0x0c, 0xe1, 0x58, 0x6c, 0x6e, 0xe1,
	0x04, 0x57, 0xd4, 0xb2, 0xe5, 0xb9, 0xd8, 0x5f, 0x16, 0x48, 0xd4, 0x6b, 0x12, 0xa0, 0x99, 0xdf,
	0xed, 0xa6, 0xd4, 0xa8, 0xf5, 0xf0, 0x32, 0x90, 0x67, 0xf2, 0x31, 0x64, 0x91, 0x34, 0x22, 0xc0,
	0x4a, 0xfd, 0xea, 0x8c, 0x66, 0x73, 0xb7, 0xc6, 0x15, 0xc8, 0x27, 0x97, 0x65, 0x29, 0xc9, 0x5e,
	0xb1, 0xb9, 0x98, 0x9d, 0xde, 0x5c, 0x58, 0xea, 0xc2, 0xcd, 0x95, 0xfa, 0x96, 0xd8, 0x5c, 0x7f,
	0x21, 0x3b, 0xc3, 0x1c, 0x38, 0x3b, 0xf7, 0xb0, 0x11, 0xff, 0xdb, 0xb6, 0x4a, 0x51, 0x25, 0x17,
	0x61, 0x1a, 0xd8, 0x26, 0xbe, 0x11, 0x0c, 0x6c, 0x1a, 0x0b, 0x31, 0x0d, 0xd7, 0x53, 0x6a, 0xb5,
	0x2d, 0x2d, 0x5e, 0x6d, 0x7c, 0xec, 0x92, 0xb5, 0x20, 0x59, 0x66, 0x63, 0x97, 0x00, 0x44, 0xfb,
	0x5b, 0x81, 0xd5, 0x6e, 0xf7, 0xa0, 0x39, 0x72, 0x10, 0xc4, 0x66, 0xaf, 0x85, 0x25, 0x93, 0x8f,
	0x60, 0x0d, 0x17, 0x11, 0xce, 0x30, 0xf3, 0xa7, 0x16, 0x8b, 0x27, 0x47, 0xb9, 0x88, 0x2f, 0x2e,
	0xa2, 0x4b, 0xc9, 0x2b, 0x55, 0x66, 0x9d, 0x20, 0xc1, 0x7d, 0xa8, 0x9a, 0x8c, 0x99, 0x96, 0x8d,
	0x6e, 0xf8, 0x22, 0x90, 0x8f, 0x0c, 0x9e, 0xcc, 0x15, 0x91, 0x4c, 0x3a, 0xf6, 0x76, 0xb7, 0xd9,
	0xe3, 0x0b, 0xac, 0xd6, 0x81, 0x82, 0x3c, 0xbe, 0x19, 0x1b, 0x16, 0xd2, 0x51, 0xfb, 0x1d, 0x87,
	0xbb, 0x39, 0x9a, 0x06, 0x8c, 0xfa, 0x6d, 0x64, 0x7a, 0x97, 0xa1, 0x1d, 0x59, 0x85, 0x02, 0xa7,
	0x7d, 0x74, 0xd5, 0x15, 0x71, 0xab, 0xac, 0x73, 0xd2, 0x3a, 0xc3, 0xa9, 0x37, 0x0d, 0x8c, 0x59,
	0x63, 0xb8, 0x8f, 0xec, 0xc3, 0xcc, 0xa6, 0xc2, 0x6f, 0x68, 0x97, 0xbe, 0xc2, 0x70, 0x06, 0x22,
	0x2c, 0x89, 0x4d, 0x66, 0x59, 0xc5, 0xfc, 0xd8, 0x81, 0x35, 0x6b, 0xea, 0xfb, 0x58, 0x9a, 0x11,
	0x50, 0xff, 0xa5, 0xe3, 0x0e, 0x85, 0x41, 0x6e, 0xa1, 0x01, 0xde, 0x17, 0xb6, 0x17, 0x30, 0xd7,
	0x1c, 0x53, 0xd1, 0xed, 0x22, 0x97, 0x8c, 0xbc, 0xa1, 0x31, 0xc1, 0x49, 0x16, 0xcd, 0xce, 0x6b,
	0xb7, 0xa0, 0x22, 0x6b, 0xe0, 0xc3, 0xe2, 0x7b, 0x23, 0xce, 0x5a, 0xd3, 0xb2, 0xe8, 0x84, 0x19,
	0x98, 0x95, 0xe8, 0x94, 0x43, 0x03, 0x51, 0xcc, 0xb2, 0xf6, 0x23, 0x94, 0x67, 0xda, 0x03, 0x67,
	0x88, 0xcf, 0x9c, 0x8d, 0xb1, 0xe3, 0x3a, 0xe3, 0xe9, 0x38, 0xce, 0x89, 0x97, 0x1f, 0xea, 0xe7,
	0xb1, 0xf8, 0xcd, 0xf3, 0x9f, 0x07, 0xbe, 0x69, 0x31, 0x4e, 0x20, 0x0e, 0x80, 0x82, 0xd4, 0xb8,
	0x4e, 0x99, 0xd5, 0x37, 0x7c, 0xfa, 0x9c, 0x62, 0x37, 0xcd, 0x7e, 0xdf, 0x98, 0x50, 0xb7, 0xcf,
	0x35, 0x99, 0xed, 0xd3, 0xc0, 0xf6, 0x46, 0x7d, 0x81, 0x89, 0xa2, 0xbd, 0x42, 0x62, 0xc9, 0x8d,
	0x71, 0x68, 0x4e, 0x26, 0xa8, 0x82, 0x1b, 0xa1, 0x30, 0x0e, 0x8f, 0xe2, 0x42, 0x8c, 0x28, 0x90,
	0xd6, 0xda, 0x96, 0xbf, 0xb5, 0xfb, 0x50, 0x88, 0x0c, 0x49, 0x74, 0x4d, 0xa5, 0x1f, 0x86, 0xe7,
	0x37, 0x92, 0x68, 0xd2, 0xd6, 0x14, 0x4a, 0xa9, 0xdb, 0xab, 0x82, 0x6f, 0x33, 0xfe, 0xa4, 0xd2,
	0xdb, 0xbd, 0xe3, 0xa7, 0xf8, 0x70, 0xae, 0x42, 0xb9, 0x73, 0xac, 0x37, 0xf5, 0xe3, 0x9e, 0x14,
	0x29, 0x64, 0x1d, 0xd4, 0x94, 0xc8, 0x38, 0xa9, 0xe3, 0x7b, 0x9a, 0x40, 0xe9, 0x89, 0xc1, 0x9f,
	0x47, 0x52, 0xef, 0xf5, 0xeb, 0x0c, 0xf2, 0x8b, 0x3c, 0x6e, 0x7f, 0xd3, 0x3e, 0xfa, 0x56, 0x0a,
	0x8d, 0xde, 0xd3, 0x8e, 0x8e, 0x5f, 0x72, 0x5b, 0x0f, 0xa0, 0x1c, 0x3f, 0xda, 0x45, 0xdc, 0xcb,
	0xb0, 0xc1, 0x3d, 0xee, 0x3f, 0xda, 0x6f, 0x36, 0x7a, 0xba, 0xd1, 0xdb, 0x3f, 0xd4, 0xbb, 0xbd,
	0xc6, 0x61, 0x07, 0x53, 0xc0, 0xa7, 0x7c, 0xef, 0x58, 0xd7, 0x8d, 0x3d, 0xbd, 0xd1, 0x52, 0x95,
	0xad, 0x1d, 0x28, 0x44, 0x7b, 0x63, 0x09, 0x32, 0x27, 0x77, 0x50, 0x83, 0xff, 0xd6, 0x45, 0x66,
	0xab, 0x51, 0xbc, 0x13, 0xfd, 0xb8, 0xbb, 0x7f, 0xd4, 0x56, 0x5f, 0x67, 0xb6, 0xbe, 0x8c, 0xee,
	0xca, 0xf8, 0xae, 0xdb, 0x80, 0x6a, 0x1c, 0x40, 0x6f, 0xc5, 0xb5, 0xbe, 0x0d, 0xd5, 0xc8, 0xfc,
	0x40, 0x6f, 0x3c, 0x92, 0xd9, 0x66, 0x9e, 0x2d, 0x89, 0xff, 0x5a, 0x77, 0xff, 0x09, 0x00, 0x00,
	0xff, 0xff, 0x20, 0xda, 0x53, 0x94, 0x7d, 0x0d, 0x00, 0x00,
}
